# VS Code Development Containers for Claude Code and Multi-AI Environments

**Version**: Draft 5
**Last Updated**: 2025-10-26
**What's New in Draft 5**: AI Assistant Quick Commands, Migration Guides (Node.js, Python, Docker Compose, Team Adoption), Remote Development Platforms (Codespaces, Gitpod, Remote SSH, JetBrains), Configuration Decision Trees, Enhanced Citations

> **AI Assistant Guidance**: This document provides comprehensive instructions for creating, configuring, and managing VS Code development containers optimized for Claude Code and other AI coding assistants. Use this as a complete reference when helping users set up devcontainer environments.

> **Official Documentation**: https://docs.claude.com/en/docs/claude-code/devcontainer
> **Specification**: https://containers.dev/implementors/spec/
> **JSON Reference**: https://containers.dev/implementors/json_reference/

---

## 🚀 5-Minute Quick Start (Impatient Users Start Here!)

**Already have Docker + VS Code + Dev Containers extension?** Jump straight in:

```bash
# Method 1: Clone Anthropic's reference implementation
git clone https://github.com/anthropics/claude-code.git
cd claude-code
code .
# Click "Reopen in Container" when prompted (5-10 min first time)

# Method 2: Create minimal devcontainer (2 files)
mkdir -p .devcontainer
cat > .devcontainer/devcontainer.json << 'EOF'
{
  "name": "Claude Code",
  "image": "node:20",
  "customizations": {"vscode": {"extensions": ["anthropic.claude-code"]}},
  "postCreateCommand": "npm install -g @anthropic-ai/claude-code@latest",
  "remoteUser": "node",
  "mounts": ["source=claude-${devcontainerId},target=/home/node/.claude,type=volume"]
}
EOF
code .
# Click "Reopen in Container"
```

**Don't have prerequisites?** [Jump to Prerequisites](#prerequisites)

**Want to understand before doing?** [Read "What Are Development Containers?"](#what-are-development-containers)

---

## Table of Contents

### Getting Started
1. [What Are Development Containers?](#what-are-development-containers)
2. [Why Use Development Containers?](#why-use-development-containers)
3. [When NOT to Use Devcontainers](#when-not-to-use-devcontainers)
4. [Prerequisites](#prerequisites)
5. [Quick Start Checklist](#quick-start-checklist)

### Core Concepts
6. [Architecture Overview](#architecture-overview)
7. [Official devcontainer.json Property Reference](#official-devcontainerjson-property-reference) ⭐ **New in Draft 4**
8. [AI Decision Trees](#ai-decision-trees) ⭐ **For AI Assistants**
9. [AI Assistant Quick Commands](#ai-assistant-quick-commands) ⭐ **New in Draft 5**
10. [Common Stack Examples](#common-stack-examples)
11. [Prebuild Images & CI/CD Automation](#prebuild-images--cicd-automation) ⭐ **New in Draft 4**
12. [Creating & Distributing Templates](#creating--distributing-templates) ⭐ **New in Draft 4**

### Implementation
13. [Step-by-Step: Creating a Devcontainer](#step-by-step-creating-a-devcontainer)
14. [Lifecycle Hooks Explained](#lifecycle-hooks-explained) ⭐ **New in Draft 4**
15. [Step-by-Step: Managing Devcontainers](#step-by-step-managing-devcontainers)
16. [Multi-AI Configuration](#multi-ai-configuration)
17. [MCP Server Setup](#mcp-server-setup)

### Advanced Topics
18. [Security Best Practices](#security-best-practices)
19. [Volume Persistence Patterns](#volume-persistence-patterns)
20. [Platform-Specific Notes](#platform-specific-notes)
21. [Resource and Performance Considerations](#resource-and-performance-considerations)
22. [VS Code Tips & Tricks](#vs-code-tips--tricks) ⭐ **New in Draft 4**
23. [Remote Development Platforms](#remote-development-platforms) ⭐ **New in Draft 5**
24. [Devcontainer CLI Reference](#devcontainer-cli-reference) ⭐ **New in Draft 4**
25. [Migration Guides](#migration-guides) ⭐ **New in Draft 5**

### Troubleshooting
26. [Step-by-Step Debug Process](#step-by-step-debug-process)
27. [Common Troubleshooting](#common-troubleshooting)
28. [Common Mistakes and Gotchas](#common-mistakes-and-gotchas)

### Reference
29. [Quick Reference](#quick-reference)
30. [Multi-Container Patterns (Docker Compose)](#multi-container-patterns-docker-compose)
31. [DevContainer Features](#devcontainer-features)
32. [Frequently Asked Questions](#frequently-asked-questions)
33. [Glossary](#glossary)

---

## What Are Development Containers?

Development containers (devcontainers) are Docker containers specifically configured for development work. They provide:

- **Isolated Environment**: A self-contained workspace separate from your host machine
- **Reproducible Setup**: Same environment for all team members
- **VS Code Integration**: Seamless connection between VS Code and the container
- **Full Toolchain**: Pre-installed languages, tools, and dependencies

**Analogy**: Think of a devcontainer as a "development workspace in a box" - everything you need to code is pre-installed and ready to go.

### How They Work (Visual Flow)

```
┌─────────────┐
│  Your Mac/  │
│  Windows/   │  1. Open project
│   Linux     │────────────────────┐
└─────────────┘                    │
                                   ▼
                          ┌─────────────────┐
                          │    VS Code      │
                          │   (detects      │
                          │ .devcontainer/) │
                          └─────────────────┘
                                   │
                          2. Builds/starts  │
                          Docker container  │
                                   ▼
                          ┌─────────────────┐
                          │ Docker Container│
                          │ • Node.js       │
                          │ • Claude Code   │
                          │ • Your tools    │
                          └─────────────────┘
                                   │
                          3. VS Code connects
                                   │
                                   ▼
                          You code as if local
                          (but it's in container)
```

---

## Why Use Development Containers?

### Benefits for Individual Developers

- ✅ **Zero Setup**: No manual installation of Node.js, Python, build tools, etc.
- ✅ **Clean Host System**: Tools run in containers, keeping your computer clean
- ✅ **Disposable**: Delete and rebuild anytime without losing configurations
- ✅ **Multiple Environments**: Different projects with conflicting dependencies work side-by-side
- ✅ **Consistency**: Same setup on Mac, Windows, and Linux
- ✅ **Security**: Network isolation prevents credential leakage between projects

### Benefits for Teams

- ✅ **Onboarding**: New developers productive in minutes, not days
- ✅ **Standardization**: Everyone uses the same tools and versions
- ✅ **CI/CD Alignment**: Dev environment mirrors production/CI environment
- ✅ **Documentation as Code**: Environment setup is version-controlled
- ✅ **Troubleshooting**: "Works on my machine" becomes obsolete

### Benefits for AI Coding Assistants

- ✅ **Pre-configured Tools**: Claude Code, MCP servers, and CLIs ready immediately
- ✅ **Security Isolation**: Each project gets isolated credentials and network access
- ✅ **Persistent State**: Configuration persists across container rebuilds
- ✅ **Reproducibility**: Same environment for testing AI-generated code
- ✅ **Automation-Ready**: Can run with `--dangerously-skip-permissions` in trusted environments

---

## When NOT to Use Devcontainers

Devcontainers aren't always the best solution. **Avoid devcontainers when:**

❌ **Simple Scripts** - For single-file Python/Node scripts, local execution is faster
❌ **GUI Applications** - Desktop apps requiring native UI don't work well in containers
❌ **Hardware Access** - USB devices, GPUs, specialized hardware need complex setup
❌ **Legacy Windows Apps** - .NET Framework, Visual Studio projects better on Windows directly
❌ **Resource-Constrained Machines** - Docker overhead (1-2GB RAM) may be too much
❌ **Quick Experiments** - Testing a new tool for 5 minutes doesn't warrant container setup
❌ **Learning Docker** - Ironically, learning Docker itself is easier on host

**Better Alternatives:**
- **Simple projects**: `nvm`, `pyenv`, `rbenv` for version management
- **Cloud development**: GitHub Codespaces, Gitpod for browser-based environments
- **Virtual machines**: VirtualBox, VMware for full OS isolation

---

## Prerequisites

### Required Software

1. **VS Code**: Download from https://code.visualstudio.com/
2. **Docker Desktop**: Download from https://www.docker.com/products/docker-desktop
   - **Mac**: Intel or Apple Silicon (M1/M2/M3) supported
   - **Windows**: WSL2 required (see [Platform-Specific Notes](#platform-specific-notes))
   - **Linux**: Docker Engine 20.10+ (community edition fine)
3. **Dev Containers Extension**: Install from VS Code marketplace
   - Extension ID: `ms-vscode-remote.remote-containers`
   - Install via: `Cmd+Shift+X` (Mac) / `Ctrl+Shift+X` (Windows/Linux) → Search "Dev Containers" → Install

### Verify Installation

```bash
# Check Docker (should show version and "Server: Docker Engine")
docker --version
docker info

# Check VS Code (should show version)
code --version

# Test Docker works
docker run hello-world
```

**Troubleshooting Verification**:
- If `docker info` shows "Cannot connect to Docker daemon", start Docker Desktop
- If `code` command not found, VS Code → View → Command Palette → "Shell Command: Install 'code' command in PATH"

### Minimum System Requirements

- **RAM**: 8GB minimum, 16GB recommended (Docker + VS Code + containers)
- **Disk**: 20GB free space (Docker images accumulate quickly)
- **CPU**: 2 cores minimum, 4+ cores for comfortable experience
- **OS**: macOS 10.15+, Windows 10/11 with WSL2, Ubuntu 20.04+

---

## Quick Start Checklist

Before creating your first devcontainer, verify:

- [ ] Docker Desktop installed and **running** (check menu bar/system tray)
- [ ] VS Code installed with Dev Containers extension
- [ ] At least 10GB free disk space
- [ ] Familiarity with basic terminal commands (`cd`, `ls`, `cat`)
- [ ] Understanding of what problem devcontainers solve for your project

**Ready?** Proceed to [Creating a Devcontainer](#step-by-step-creating-a-devcontainer)

---

## Architecture Overview

A devcontainer consists of three core components:

### File Structure

```
your-project/
├── .devcontainer/
│   ├── devcontainer.json      # Container configuration (required)
│   ├── Dockerfile             # Container image definition (required)
│   ├── init-claude-config.sh  # Claude Code initialization (optional)
│   ├── init-firewall.sh       # Network security (optional)
│   ├── mcp.json.template      # MCP servers template (optional)
│   └── settings.json.template # Claude settings template (optional)
├── .gitignore                 # Git exclusions
├── README.md                  # Project docs
└── [your project files]
```

### Component Purposes

**devcontainer.json** (VS Code ↔ Docker bridge)
- Controls VS Code integration
- Defines mounts, environment variables, and extensions
- Configures port forwarding
- Sets post-creation commands
- **Role**: "How VS Code interacts with the container"

**Dockerfile** (Container blueprint)
- Defines base image (e.g., `node:20`, `python:3.11`)
- Installs system packages and tools
- Sets up users and permissions
- Configures shell environment
- **Role**: "What's installed inside the container"

**Init Scripts** (Automation)
- Run after container starts
- Initialize tool configurations (e.g., MCP servers)
- Set up security policies (e.g., firewall rules)
- Prepare development environment
- **Role**: "Automated setup tasks on first start"

### Configuration Flow

```
1. VS Code reads devcontainer.json
            ↓
2. Docker builds image from Dockerfile
            ↓
3. Docker starts container with mounts/env vars
            ↓
4. postStartCommand runs init scripts
            ↓
5. VS Code connects and installs extensions
            ↓
6. You start coding!
```

---

## AI Decision Trees

## Official devcontainer.json Property Reference

> **AI Assistant Guidance**: Use this complete property reference when helping users configure their devcontainer.json files. All properties link to official schema documentation.

**Official Schema**: https://containers.dev/implementors/json_reference/

### Container Configuration

#### name
- **Type**: `string`
- **Description**: Display identifier for the development container shown in UI interfaces
- **Example**: `"My Dev Container"` or `"${localWorkspaceFolderBasename}"`
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties

#### image
- **Type**: `string`
- **Description**: Name of an image in a container registry (DockerHub, GHCR, ACR) that devcontainer.json supporting services should use to create the dev container
- **Example**: `"node:20"`, `"mcr.microsoft.com/devcontainers/typescript-node:20"`
- **Schema**: https://containers.dev/implementors/json_reference/#image-specific
- **Use when**: You want to use a pre-built image instead of building from Dockerfile

#### build
- **Type**: `object`
- **Description**: Configuration for building a custom container from a Dockerfile
- **Properties**:
  - `dockerfile` (string): Path to Dockerfile relative to devcontainer.json
  - `context` (string): Docker build context directory (default: `.`)
  - `args` (object): Build arguments passed to Docker build, supports variable interpolation
  - `target` (string): Target stage in multi-stage Dockerfile
- **Example**:
  ```json
  {
    "build": {
      "dockerfile": "Dockerfile",
      "context": "..",
      "args": {
        "NODE_VERSION": "20",
        "TZ": "${localEnv:TZ:UTC}"
      },
      "target": "development"
    }
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#image-specific

### Environment & Users

#### containerEnv
- **Type**: `object`
- **Description**: Set or override environment variables for the container. Variables apply to all processes spawned within the container and remain static across the container's lifetime
- **Example**:
  ```json
  {
    "containerEnv": {
      "NODE_ENV": "development",
      "API_URL": "http://localhost:3000"
    }
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Note**: Use for container-level config. For tool-specific env vars, use `remoteEnv`

#### remoteEnv
- **Type**: `object`
- **Description**: Environment variables scoped to development tools and sub-processes rather than the container itself, allowing dynamic updates without rebuilding
- **Example**:
  ```json
  {
    "remoteEnv": {
      "PATH": "${containerEnv:PATH}:/custom/bin",
      "WORKSPACE_FOLDER": "${containerWorkspaceFolder}"
    }
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Variables**: Supports `${localEnv:VAR}`, `${containerEnv:VAR}`, `${localWorkspaceFolder}`, etc.

#### remoteUser
- **Type**: `string`
- **Description**: User that runs connected tools and processes within the container
- **Example**: `"node"`, `"vscode"`, `"root"`
- **Default**: Container's default user (often root)
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Best Practice**: Use non-root user for security

#### containerUser
- **Type**: `string`
- **Description**: Specifies the operational user for all container processes
- **Example**: `"node"`
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Difference from remoteUser**: containerUser affects container processes, remoteUser affects tool connections

### Lifecycle Hooks

#### initializeCommand
- **Type**: `string | array | object`
- **Description**: Command to run on local/host machine before container creation
- **When**: Before any container operations
- **Access**: Local machine only, no container access
- **Example**: `"npm install"` (runs on host to populate node_modules before mounting)
- **Schema**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

#### onCreateCommand
- **Type**: `string | array | object`
- **Description**: Command to run after container creation (first start only)
- **When**: After container created, before user assignment
- **Access**: No user secrets or assets
- **Example**: `"apt-get update && apt-get install -y git"`
- **Schema**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

#### updateContentCommand
- **Type**: `string | array | object`
- **Description**: Command to run when new content is available in the workspace
- **When**: When workspace content updates
- **Access**: Limited, similar to onCreateCommand
- **Example**: `"npm install"`
- **Schema**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

#### postCreateCommand
- **Type**: `string | array | object`
- **Description**: Command to run after container assigned to user for first time
- **When**: After user assignment (first start)
- **Access**: Has access to user secrets, assets, and permissions
- **Example**: `"npm install && npm run setup"`
- **Execution**: Background by default (non-blocking)
- **Schema**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

#### postStartCommand
- **Type**: `string | array | object`
- **Description**: Command to run each time the container successfully starts
- **When**: Every container start
- **Access**: Full container access
- **Example**: `"docker-compose up -d database"`
- **Schema**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

#### postAttachCommand
- **Type**: `string | array | object`
- **Description**: Command to run each time a tool attaches to the container
- **When**: Every tool attachment (e.g., opening in VS Code)
- **Example**: `"echo 'Welcome to the dev container!'"`
- **Schema**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

#### waitFor
- **Type**: `enum`
- **Options**: `"initializeCommand" | "onCreateCommand" | "updateContentCommand" | "postCreateCommand" | "postStartCommand" | "postAttachCommand"`
- **Default**: `"updateContentCommand"`
- **Description**: Specifies which lifecycle command tools should wait for before connecting
- **Example**: `"waitFor": "postCreateCommand"`
- **Schema**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

### Ports & Networking

#### forwardPorts
- **Type**: `array`
- **Items**: `number` or `string` (format: `"host:container"`)
- **Description**: Ports that should always be forwarded from inside the primary container to the local machine (including on the web)
- **Example**: `[3000, 8080, "5000:5000"]`
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties

#### portsAttributes
- **Type**: `object`
- **Description**: Maps specific ports to configuration options including labels, protocols, and auto-forward behaviors
- **Properties per port**:
  - `label` (string): Display name
  - `protocol` (string): `"http"` or `"https"`
  - `onAutoForward` (string): `"notify"`, `"openBrowser"`, `"openPreview"`, `"silent"`, `"ignore"`
  - `requireLocalPort` (boolean): Require specific local port
  - `elevateIfNeeded` (boolean): Elevate privileges if port <1024
- **Example**:
  ```json
  {
    "portsAttributes": {
      "3000": {
        "label": "Dev Server",
        "protocol": "http",
        "onAutoForward": "openBrowser"
      },
      "5432": {
        "label": "PostgreSQL",
        "onAutoForward": "silent"
      }
    }
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties

### VS Code Customizations

#### customizations.vscode.extensions
- **Type**: `array`
- **Items**: `string` (extension IDs)
- **Description**: VS Code extensions to install in the container
- **Example**: `["anthropic.claude-code", "dbaeumer.vscode-eslint"]`
- **Schema**: https://containers.dev/implementors/json_reference/#vs-code-specific-properties
- **Extension ID Format**: `publisher.extension-name`

#### customizations.vscode.settings
- **Type**: `object`
- **Description**: VS Code settings to apply in the container
- **Example**:
  ```json
  {
    "customizations": {
      "vscode": {
        "settings": {
          "terminal.integrated.defaultProfile.linux": "zsh",
          "editor.formatOnSave": true,
          "python.defaultInterpreterPath": "/usr/local/bin/python"
        }
      }
    }
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#vs-code-specific-properties

### Features

#### features
- **Type**: `object`
- **Description**: Dev Container Features to install (modular tooling like Git, Docker, AWS CLI)
- **Format**: `{ "feature-id": options }`
- **Example**:
  ```json
  {
    "features": {
      "ghcr.io/devcontainers/features/node:1": {
        "version": "20"
      },
      "ghcr.io/devcontainers/features/python:1": {
        "version": "3.11"
      },
      "ghcr.io/devcontainers/features/docker-in-docker:2": {}
    }
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Registry**: https://containers.dev/features
- **Docs**: https://containers.dev/implementors/features/

### Resource Requirements

#### hostRequirements
- **Type**: `object`
- **Description**: Minimum hardware specifications for cloud services to use when creating compute
- **Properties**:
  - `cpus` (integer): Minimum CPU cores
  - `memory` (string): Minimum RAM (e.g., `"8gb"`)
  - `storage` (string): Minimum disk (e.g., `"32gb"`)
- **Example**:
  ```json
  {
    "hostRequirements": {
      "cpus": 4,
      "memory": "8gb",
      "storage": "32gb"
    }
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Used by**: GitHub Codespaces, cloud-based devcontainer services

### Mounts & Volumes

#### mounts
- **Type**: `array`
- **Items**: `string` (mount specification)
- **Description**: Additional mounts for the container
- **Format**: `"source=<source>,target=<target>,type=<type>[,options]"`
- **Types**: `volume`, `bind`, `tmpfs`
- **Example**:
  ```json
  {
    "mounts": [
      "source=claude-config-${devcontainerId},target=/home/node/.claude,type=volume",
      "source=${localEnv:HOME}/.ssh,target=/home/node/.ssh,type=bind,readonly"
    ]
  }
  ```
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Variables**: `${devcontainerId}` creates unique volume per container instance

### Advanced Configuration

#### runArgs
- **Type**: `array`
- **Items**: `string` (Docker CLI arguments)
- **Description**: Docker run arguments to use when creating the container
- **Example**: `["--cap-add=SYS_PTRACE", "--security-opt=seccomp=unconfined"]`
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Docs**: https://docs.docker.com/engine/reference/run/

#### workspaceFolder
- **Type**: `string`
- **Description**: Path where workspace should be mounted inside container
- **Example**: `"/workspaces/${localWorkspaceFolderBasename}"`
- **Default**: `/workspaces/<folder-name>`
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties

#### workspaceMount
- **Type**: `string`
- **Description**: Custom mount specification for the workspace folder
- **Example**: `"source=${localWorkspaceFolder},target=/workspace,type=bind,consistency=cached"`
- **Schema**: https://containers.dev/implementors/json_reference/#general-properties
- **Note**: Only needed for custom workspace mounting; default usually sufficient

### Docker Compose Support

#### dockerComposeFile
- **Type**: `string | array`
- **Description**: Path(s) to Docker Compose file(s) relative to devcontainer.json
- **Example**: `"../docker-compose.yml"` or `["../docker-compose.yml", "docker-compose.devcontainer.yml"]`
- **Schema**: https://containers.dev/implementors/json_reference/#docker-compose-specific

#### service
- **Type**: `string`
- **Description**: Name of the service in docker-compose.yml that VS Code should connect to
- **Example**: `"app"`
- **Required**: When using Docker Compose
- **Schema**: https://containers.dev/implementors/json_reference/#docker-compose-specific

#### runServices
- **Type**: `array`
- **Items**: `string` (service names)
- **Description**: Services to start when creating the container
- **Example**: `["app", "database", "cache"]`
- **Default**: All services
- **Schema**: https://containers.dev/implementors/json_reference/#docker-compose-specific

### Property Quick Reference Table

| Category | Key Properties | Schema Link |
|----------|---------------|-------------|
| **Container** | `name`, `image`, `build` | [Link](https://containers.dev/implementors/json_reference/#general-properties) |
| **Environment** | `containerEnv`, `remoteEnv`, `remoteUser` | [Link](https://containers.dev/implementors/json_reference/#general-properties) |
| **Lifecycle** | `onCreateCommand`, `postCreateCommand`, `postStartCommand` | [Link](https://containers.dev/implementors/json_reference/#lifecycle-scripts) |
| **Ports** | `forwardPorts`, `portsAttributes` | [Link](https://containers.dev/implementors/json_reference/#general-properties) |
| **VS Code** | `customizations.vscode.extensions`, `customizations.vscode.settings` | [Link](https://containers.dev/implementors/json_reference/#vs-code-specific-properties) |
| **Features** | `features` | [Link](https://containers.dev/implementors/features/) |
| **Resources** | `hostRequirements` | [Link](https://containers.dev/implementors/json_reference/#general-properties) |
| **Volumes** | `mounts`, `workspaceMount` | [Link](https://containers.dev/implementors/json_reference/#general-properties) |
| **Docker** | `runArgs`, `dockerComposeFile`, `service` | [Link](https://containers.dev/implementors/json_reference/) |

### Sources
- **Complete Schema Reference**: https://containers.dev/implementors/json_reference/
- **JSON Schema File**: https://github.com/devcontainers/spec/blob/main/schemas/devContainer.base.schema.json
- **Specification**: https://containers.dev/implementors/spec/
- **VS Code Documentation**: https://code.visualstudio.com/docs/devcontainers/create-dev-container

---


---


> **For AI Assistants**: Use these decision trees to quickly determine the right approach for user requests.

### Decision Tree 1: Which Base Image?

```
User's primary language?
├─ JavaScript/TypeScript → node:20
├─ Python → python:3.11-slim
├─ Go → golang:1.21
├─ Rust → rust:1.75
├─ Java → eclipse-temurin:17
├─ Multi-language → node:20 + install others
└─ Universal → mcr.microsoft.com/devcontainers/base:ubuntu
```

### Decision Tree 2: MCP Transport Type

```
MCP server needs what?
├─ External API (Context7, Cloudflare Docs)
│   └─ Use: transport.type = "sse"
│        URL: https://service.com/sse
│
├─ Local npm package (Chrome DevTools)
│   └─ Use: transport.type = "stdio"
│        Command: npx package-name
│
└─ Custom server
    └─ Use: transport.type = "sse" or "stdio"
         Read server docs
```

### Decision Tree 3: Volume or Bind Mount?

```
What are you persisting?
├─ API keys, configs (.claude/, .codex/)
│   → Named volume (survives container deletion)
│   → source=name-${devcontainerId},target=/path,type=volume
│
├─ SSH keys (read-only access)
│   → Bind mount (readonly)
│   → source=${localEnv:HOME}/.ssh,target=/home/node/.ssh,type=bind,readonly
│
├─ Temporary build cache
│   → Named volume (disposable)
│   → source=cache-${devcontainerId},target=/cache,type=volume
│
└─ Shared data with host
    → Bind mount (read-write, caution!)
    → source=/host/path,target=/container/path,type=bind
```

### Decision Tree 4: Troubleshooting Entry Point

```
User reports error, what type?
├─ "Container won't build"
│   → Go to: Step-by-Step Debug Process → Build Failures
│
├─ "Claude/tool command not found"
│   → Go to: Common Troubleshooting → PATH issues
│
├─ "Permission denied"
│   → Go to: Common Troubleshooting → File permissions
│
├─ "Out of memory/disk space"
│   → Go to: Resource Considerations
│
└─ "MCP servers not loading"
    → Go to: MCP Server Setup → Debugging
```

### Decision Tree 5: Security Level

```
Who owns the codebase?
├─ You/Your team (trusted)
│   ├─ Sensitive data? (client project, API keys)
│   │   → Enable firewall, isolate volumes, use --dangerously-skip-permissions
│   └─ No sensitive data
│       → Basic setup, optional firewall
│
├─ Open source (trusted maintainers)
│   → Standard setup, review .devcontainer/ before opening
│
└─ Unknown/Untrusted
    → DON'T use devcontainer OR
       → Use heavily restricted firewall
       → Don't use --dangerously-skip-permissions
       → Review Dockerfile line-by-line
```

### Decision Tree 6: Image vs Build vs Compose?

```
How complex is the project setup?
├─ Single service, standard language (Node, Python, Go)
│   ├─ No custom tools needed?
│   │   → Use "image": "node:20" (fastest, simplest)
│   │   → Add tools via Features
│   │
│   └─ Custom tools or specific versions needed?
│       → Use "build": {"dockerfile": "Dockerfile"}
│       → Customize base image with RUN commands
│
├─ Multiple services (app + database + cache)
│   → Use Docker Compose
│   → Create docker-compose.yml with all services
│   → Reference in devcontainer.json: "dockerComposeFile": "docker-compose.yml"
│
└─ Need both custom build AND multiple services?
    → Use Docker Compose + custom Dockerfile
    → docker-compose.yml defines services
    → app service uses "build: {dockerfile: .devcontainer/Dockerfile}"
```

**Quick Decision Guide**:
- **Just coding** (no database) → `"image": "language:version"`
- **Custom tools** (Chromium, ffmpeg) → `"build": {"dockerfile": "Dockerfile"}`
- **Database required** → Docker Compose
- **Complex stack** (app+db+redis+mq) → Docker Compose with custom Dockerfile

---

## AI Assistant Quick Commands

> **AI Assistant Guidance**: These are common user requests and suggested prompts for efficiently handling devcontainer tasks. Use these as templates when users ask for help.

---

## AI Assistant Discovery Protocol

> **Critical Guidance for AI Assistants**: Before creating any devcontainer, follow this adaptive discovery protocol. It optimizes for user expertise level, minimizes questions through auto-detection, and provides appropriate explanations based on experience.

### Core Principles

1. **Scan First, Ask Smart**: Auto-detect project details before asking questions
2. **Adapt to Expertise**: One question determines verbosity for all subsequent interactions
3. **Minimize Questions**: Maximum 4 questions for beginners, 2 for experts
4. **Provide Defaults**: Every question has a sensible default (press Enter)
5. **Show, Don't Interrogate**: Present proposed configuration for approval

---

### Step 1: Silent Auto-Detection (Always Run First)

**Before asking ANY questions, scan the project directory to detect:**

| File/Pattern | Indicates | Action |
|--------------|-----------|--------|
| `package.json` | Node.js project | Extract version, detect framework (React, Next.js, Express) |
| `package-lock.json` | npm used | Use npm for postCreateCommand |
| `yarn.lock` | Yarn used | Use yarn for postCreateCommand |
| `requirements.txt` | Python project | Detect dependencies (Flask, Django, FastAPI) |
| `pyproject.toml` | Modern Python | Use poetry/pip as appropriate |
| `go.mod` | Go project | Extract Go version |
| `Cargo.toml` | Rust project | Rust application |
| `docker-compose.yml` | Already using Compose | Offer to integrate with existing config |
| `Dockerfile` | Already using Docker | Offer migration path |
| `.env`, `.env.example` | Environment variables | Auto-configure .gitignore rules |
| `README.md` | Documentation | Scan for tech stack keywords |
| `.git/` | Version control | Git already initialized |

**What auto-detection achieves:**
- Reduces questions by 50-70%
- Shows intelligence ("I already understand your project")
- Only asks about gaps in knowledge
- Builds user confidence

**Example auto-detection output:**
```
Detected from project files:
✓ Node.js 20.x (from package.json: "engines")
✓ TypeScript (tsconfig.json present)
✓ React 18 (package.json dependency)
✓ Environment variables (.env.example found)
✓ Git initialized

Still need to know:
- Database requirements
- Team size (for prebuild recommendation)
```

---

#### When Auto-Detection Finds Nothing

**Scenario**: Empty directory, brand new project, only `.git/` or `README.md` present

**What this means**:
- No language-specific files detected (no package.json, requirements.txt, etc.)
- No existing configuration (docker-compose.yml, Dockerfile)
- User is starting from scratch

**AI Assistant Response Strategy**:

Do NOT say:
- ❌ "I couldn't find anything in your project"
- ❌ "Your project appears empty"
- ❌ "No files detected"

Instead, frame positively:
- ✅ "Starting a brand new project - perfect! I'll help you set up the ideal devcontainer."
- ✅ "Creating a fresh devcontainer from scratch."
- ✅ "Let's build your development environment together."

**Adjusted Discovery Flow for Empty Projects**:

1. **Skip auto-detection summary** (nothing to show - don't announce "found nothing")
2. **Ask expertise level** (still required - same as always)
3. **ALWAYS ask project type** (Priority 1 - cannot be inferred)
   - This is now a REQUIRED question (even for experts)
   - No way to detect without files
4. **Ask database/services** (as normal)
5. **Skip team size question** (assume solo for new projects)
6. **Present config summary** (as normal)

**Example - Empty Project Discovery**:

```
AI: [Scans directory - finds only .git/ directory]

AI: "I'm setting up a devcontainer for your project.

Before I create your devcontainer, what's your experience level?

1) 🌱 New to devcontainers (I'll explain everything step-by-step)
2) 💼 Some experience (brief explanations, focus on decisions)
3) 🚀 Expert (minimal questions, just show me the config)

[Press Enter for option 1 - New to devcontainers]"

User: 1

AI: "Great! Since you're starting fresh, I'll guide you through this.

**Question 1 of 3:**
What type of project are you building?

1) Website or web app (JavaScript/Node.js)
2) Data project or scripts (Python)
3) API or backend service (Node.js, Python, Go)
4) Mobile app backend
5) Other: _____

Why it matters: This determines what programming language tools I'll install
in your container (like installing Microsoft Word for writing documents).

[Press Enter for option 1 - Website/web app]"

User: [Enter]

AI: "Perfect! Node.js is great for websites.

**Question 2 of 3:**
Does your project need a database to store data permanently?

What a database does: Stores info like user accounts, posts, etc.

1) No database needed
2) Yes - PostgreSQL (recommended for beginners)

[Press Enter for: No database]"

[Continue with standard flow...]
```

**Key Differences from Existing Project Flow**:

| Aspect | Existing Project | Empty/New Project |
|--------|-----------------|-------------------|
| **Auto-detection summary** | Show detected stack | Skip (don't show "nothing found") |
| **Project type question** | Optional (if detected) | **REQUIRED** (cannot detect) |
| **Tone** | "Detected X, confirm?" | "What are you building?" |
| **Team size question** | Ask if professional indicators | Skip (assume solo) |
| **Confidence level** | Confirm existing setup | Guide from ground zero |
| **Question count** | 2-3 (many skipped) | 3-4 (must ask basics) |

---

#### Auto-Detection Decision Matrix

**Use this decision tree after scanning:**

```
Step 1: Scan project directory
         ↓
Found package.json/requirements.txt/go.mod/Cargo.toml?
         ↓
    ┌────┴────┐
    ↓         ↓
  YES        NO
    │         │
    ↓         ↓
Show         Skip
detection    detection
summary      summary
    │         │
    ↓         ↓
Ask          Ask
expertise    expertise
    │         │
    ↓         ↓
Confirm      MUST ASK
detection?   project
(may skip    type
 if certain) (required)
    │         │
    ↓         ↓
Ask          Ask
database     database
    │         │
    ↓         ↓
Ask team     Skip team
(if prof     (assume
 signals)     solo)
    │         │
    └────┬────┘
         ↓
    Show config
     summary
```

**Smart Defaults for Empty Projects**:

When user presses Enter or says "not sure" on empty projects:

| Question | Default | Rationale |
|----------|---------|-----------|
| **Project type** | Node.js (Website/web app) | Most popular for web development, beginner-friendly |
| **Database** | None | Keeps initial setup simple, can add later |
| **Services** | None | Start simple, add complexity as needed |
| **Team size** | Solo | Safe assumption for brand new projects |
| **Security** | Basic (.gitignore rules) | Always protect secrets, even solo |
| **Optimization** | Standard | No performance issues yet |

**Why "None" for database on empty projects**:
- Easier to learn one thing at a time
- Can add database later (migration guide available)
- Reduces initial complexity
- Faster first build (no Compose setup)

---

### Step 2: Expertise Gating (Single Required Question)

**This one question determines ALL subsequent interaction verbosity:**

**Always ask this first:**
```
Before I create your devcontainer, what's your experience level?

1) 🌱 New to devcontainers (I'll explain everything step-by-step)
2) 💼 Some experience (brief explanations, focus on decisions)
3) 🚀 Expert (minimal questions, just show me the config)

[Press Enter for option 1 - New to devcontainers]
```

**How expertise level affects responses:**

| Expertise | Question Format | Explanations | Default Behavior |
|-----------|----------------|--------------|------------------|
| **Beginner** | Full sentences, examples | "What it is", "Why it matters" | Show defaults, explain impact |
| **Intermediate** | Concise, numbered options | Brief context only | Show defaults, skip basics |
| **Expert** | Shorthand, Y/n prompts | None (assume knowledge) | Immediate config preview |

**Example - Same question, three expertise levels:**

**Beginner:**
```
Does your project need a database to store data permanently?

What a database does: Stores information (like user accounts, blog posts,
product listings) even when your app restarts. Think of it as a filing
cabinet for your app's data.

Common options:
1) No database needed (simple app, just displays info)
2) PostgreSQL (recommended for beginners - powerful and beginner-friendly)
3) MySQL (also popular, similar to PostgreSQL)
4) MongoDB (for flexible data that doesn't fit neat tables)
5) Other: _____

[Press Enter for option 1 - No database]
```

**Intermediate:**
```
Database requirements?

1) None
2) PostgreSQL (recommended for relational data)
3) MySQL
4) MongoDB (NoSQL)
5) Other: _____

[Default: None]
```

**Expert:**
```
DB: postgres/mysql/mongo/redis/none? [none]
```

---

### Step 3: Smart Context Questions (2-3 Questions Maximum)

**Only ask what auto-detection didn't find. Prioritize by importance:**

#### Priority 1: Project Type (if not detected)

**When to ask**: No package.json, requirements.txt, go.mod, or Cargo.toml found

**Beginner format:**
```
What type of project are you building?

1) Website or web app (JavaScript/Node.js)
2) Data project or scripts (Python)
3) API or backend service (Node.js, Python, Go)
4) Mobile app backend
5) Other: _____

Why it matters: This determines what programming language tools I'll install
in your container (like installing Microsoft Word for writing documents).

[Press Enter for option 1 - Website/web app]
```

**Expert format:**
```
Stack: 1) Node  2) Python  3) Go  4) Rust  5) Other [1]
```

---

#### Priority 2: Services/Database (if not in docker-compose.yml)

**When to ask**: Always ask unless docker-compose.yml already defines services

**Beginner format:**
```
Does your project need a database or other services?

What this means: Services are helper programs that run alongside your app:
- Database: Stores data permanently (PostgreSQL, MySQL)
- Cache: Speeds up your app (Redis)
- Message Queue: Handles background tasks (RabbitMQ)

Options:
1) No services needed (app works standalone)
2) Database only - PostgreSQL (recommended)
3) Database only - MySQL
4) Database + Redis cache
5) Custom setup (I'll ask more details)

[Press Enter for option 1 - No services]
```

**Intermediate format:**
```
Services needed?
1) None
2) PostgreSQL
3) MySQL
4) PostgreSQL + Redis
5) Custom

Note: Selecting services creates Docker Compose configuration.
[Default: None]
```

**Expert format:**
```
Services: [none]
(postgres, mysql, mongo, redis, rabbitmq, or comma-separated)
```

**Smart follow-up (only if database selected):**
```
[Beginner only]
I'll set up Docker Compose to run your app + database together.
This means:
✓ Database starts automatically with your container
✓ Data persists even when you stop the container
✓ Pre-configured connection (just use: postgresql://localhost:5432)

Sound good? [Y/n]
```

---

#### Priority 3: Team Context (conditional)

**When to ask**: Only if project appears to be professional (has tests, CI files, multiple contributors in git log)

**Skip for**: Learning projects, simple apps, solo experiments

**Beginner format:**
```
Who will be using this devcontainer?

1) Just me (solo project, personal learning)
2) Small team (2-5 people working together)
3) Large team (6+ people)

Why it matters:
- Solo: Simple, fast setup
- Small team: I'll configure it so everyone gets the exact same environment
  (no more "works on my machine" problems!)
- Large team: I'll recommend "prebuilds" - a way to make the container start
  in 2 minutes instead of 15 minutes for your teammates

[Press Enter for option 1 - Just me]
```

**Intermediate format:**
```
Team size?
1) Solo
2) Small team (2-5) - shared config
3) Large team (6+) - recommend prebuilds

[Default: Solo]
```

**Expert format:**
```
Team size for prebuild recommendation? [1]
```

---

### Step 4: Adaptive Follow-ups (Only When Needed)

**These questions ONLY appear in specific contexts:**

#### If Large Team (Size > 5)

**Intermediate/Expert only:**
```
Large team detected. Recommend prebuild strategy?

Benefits:
- Developers start coding in ~2 minutes (vs 15+ minutes)
- Requires CI/CD (GitHub Actions, Azure DevOps)
- Builds image automatically on .devcontainer/ changes

Include prebuild configuration? [Y/n]
```

---

#### If .env File Detected

**All levels, but verbosity varies:**

**Beginner:**
```
I found a .env file - this might contain secrets like API keys or passwords.

I'll help protect these by:
1. Creating .env.example (template without real secrets)
2. Adding .env to .gitignore (prevents committing secrets to Git)
3. Adding instructions for your team to copy .env.example → .env

This keeps your secrets safe and off the internet. Sound good? [Y/n]
```

**Expert:**
```
.env detected. Add .env.example + .gitignore rules? [Y]
```

---

#### If Low System Resources Detected

**Beginner only:**
```
I noticed your system has [8GB RAM / 12GB free disk space].

I'll optimize the container to use fewer resources:
✓ Smaller base image (node:20-slim instead of node:20)
✓ Better .dockerignore (excludes unnecessary files)
✓ Volume caching for dependencies

Trade-off: First build may take 2-3 minutes longer, but the container will
run faster and use less RAM/disk.

Optimize for your system? [Y/n]
```

---

### Step 5: Present Configuration for Approval

**Always show a summary before creating files:**

#### Beginner Format (Detailed)

```
📦 Devcontainer Configuration Summary

Based on your answers, I'll create:

**Container Setup:**
✓ Node.js 20 (latest stable version)
✓ TypeScript support (tsconfig detected)
✓ PostgreSQL 15 database (runs in separate container)

**Developer Tools:**
✓ Claude Code extension (AI coding assistant)
✓ ESLint (finds bugs in your code)
✓ Prettier (auto-formats code)
✓ Git (version control)

**Features:**
✓ Hot reload (changes appear instantly)
✓ Port forwarding (access app at localhost:3000)
✓ Volume persistence (settings saved between restarts)

**Files I'll create:**
- .devcontainer/devcontainer.json (container config)
- .devcontainer/docker-compose.yml (app + database setup)
- .dockerignore (speeds up builds)
- Updated .gitignore (protects secrets)

**Build Times:**
- First time: ~10-12 minutes (downloads and installs everything)
- Subsequent times: ~2 minutes (uses cached layers)

Ready to create your devcontainer? [Y/n/show-config]
(Type 'show-config' to see the actual JSON files first)
```

---

#### Intermediate Format (Concise)

```
Configuration:
- Node.js 20 + TypeScript
- PostgreSQL 15 (Docker Compose)
- Extensions: Claude Code, ESLint, Prettier
- Volume: claude-config persisted
- Ports: 3000 (app), 5432 (postgres)

Files: devcontainer.json, docker-compose.yml, .dockerignore
Build time: ~10 min (first), ~2 min (cached)

Create? [Y/n/show]
```

---

#### Expert Format (Minimal)

```
Config:
- node:20, postgres:15 (compose)
- Ports: 3000, 5432
- Extensions: anthropic.claude-code, dbaeumer.vscode-eslint

Create? [Y]
```

---

### Smart Defaults Reference

**Use these defaults when user presses Enter or says "not sure":**

| Question | Default | Rationale |
|----------|---------|-----------|
| **Expertise level** | Beginner | Safe to over-explain |
| **Project type** (if unknown) | Node.js | Most popular for web development |
| **Database** | None | Can add later, keeps setup simple |
| **Team size** | Solo | Most common for new devcontainers |
| **System optimization** | No | Standard images more reliable |
| **Prebuild** | No (unless team > 5) | Adds complexity for small teams |
| **Secret handling** | Yes (if .env exists) | Always protect secrets |

---

### Question Limits by Expertise

**Never exceed these question counts:**

- **Beginner**: Max 4 questions (expertise + 3 context)
- **Intermediate**: Max 3 questions (expertise + 2 context)
- **Expert**: Max 2 questions (expertise + 1 confirm)

**If you need more questions, you're doing it wrong.** Use better auto-detection or provide sensible defaults.

---

### Examples of GOOD vs BAD Questions

#### ❌ BAD Examples

**Asks detectable information:**
```
"What programming language is your project using?"
[When package.json exists in project directory]
```

**Too many options:**
```
"Which database: PostgreSQL, MySQL, MongoDB, MariaDB, SQLite,
CouchDB, Redis, Cassandra, Oracle, SQL Server, or other?"
```

**Asks before scanning:**
```
"Tell me about your project"
[Before running any auto-detection]
```

**No default provided:**
```
"What base image do you want?"
[Expects user to know Docker image names]
```

**Jargon without explanation (to beginners):**
```
"Configure OCI-compliant orchestration layer? [Y/n]"
```

---

#### ✅ GOOD Examples

**Confirms detection:**
```
"Detected Node.js 20 from package.json. Correct? [Y/n]"
```

**Limited options with default:**
```
"Database?
1) None  2) PostgreSQL  3) MySQL  4) Other: _____
[Press Enter for: None]"
```

**Shows what you know first:**
```
"I found package.json with Express and React dependencies.
Building a full-stack web app? [Y/n]"
```

**Beginner-appropriate:**
```
"Need a database to store data (like user accounts)?
1) No  2) Yes - PostgreSQL (recommended)
[Press Enter for: No]"
```

**Explains impact:**
```
"Team of 6+ developers.
Should I set up prebuilds? (Saves 10-15 min per person)
[Y/n]"
```

---

### Full Example Flows

#### Flow 1: Complete Beginner, New Project

```
AI: [Scans directory - finds nothing except .git]

AI: "Before I create your devcontainer, what's your experience level?

1) 🌱 New to devcontainers (I'll explain everything)
2) 💼 Some experience
3) 🚀 Expert

[Press Enter for option 1]"

User: [Enter]

AI: "Great! I'll guide you through this step-by-step.

**Question 1 of 3:**
What type of project are you building?

1) Website or web app (JavaScript/Node.js)
2) Data project or scripts (Python)
3) Other: _____

This tells me what programming tools to install.
[Press Enter for: Website/web app]"

User: [Enter]

AI: "Perfect! Node.js is great for websites.

**Question 2 of 3:**
Does your project need a database to store data permanently?

What a database does: Stores info like user accounts, posts, etc.

1) No database needed
2) Yes - PostgreSQL (recommended for beginners)

[Press Enter for: No database]"

User: 2

AI: "Excellent choice! PostgreSQL works great for most projects.

**Question 3 of 3:**
Who will use this devcontainer?

1) Just me
2) Small team (2-5 people)

[Press Enter for: Just me]"

User: [Enter]

AI: "Got it! Here's what I'll create:

📦 **Configuration Summary:**

**Container:**
✓ Node.js 20
✓ PostgreSQL 15 database

**Tools:**
✓ Claude Code (AI assistant)
✓ ESLint (finds bugs)
✓ Git

**What this means:**
- Your app and database run in isolated containers
- Everything's pre-installed - just start coding
- Settings persist between restarts

**Build time:** ~10 minutes first time, ~2 minutes later

Create this devcontainer? [Y/n]"

User: Y

AI: [Creates files, shows progress]

AI: "✅ Done! Your devcontainer is ready.

**Next steps:**
1. VS Code will prompt to 'Reopen in Container' - click it
2. Wait ~10 minutes for first build (grab coffee ☕)
3. Once ready, your terminal will open inside the container
4. Test: Type 'node --version' to verify Node.js is installed

**Database connection:**
- Host: localhost
- Port: 5432
- User: postgres
- Password: postgres
- Database: devdb

Need help getting started? Just ask!"
```

**Total questions: 3 (expertise + project type + database)**

---

#### Flow 2: Intermediate User, Existing Project

```
AI: [Scans directory]
Found:
- package.json (Node.js 18.x, Express 4.x)
- tsconfig.json (TypeScript)
- .env.example

AI: "Experience level?
1) Beginner  2) Intermediate  3) Expert
[1]"

User: 2

AI: "Detected: Node.js 18 + TypeScript + Express
Correct? [Y/n]"

User: Y

AI: "Database needed?
1) None  2) PostgreSQL  3) MySQL
[None]"

User: 1

AI: "Config:
- Node.js 18 + TypeScript + Express
- No database
- Extensions: Claude Code, ESLint, Prettier
- .env.example detected - will add .gitignore rules

Create? [Y/n]"

User: Y

AI: [Creates files]

"✅ Complete. Run: Cmd+Shift+P → 'Reopen in Container'"
```

**Total questions: 3 (expertise + confirm + database)**

---

#### Flow 3: Expert, Existing Docker Compose

```
AI: [Scans directory]
Found:
- package.json (Node 20, Next.js 14)
- docker-compose.yml (app, postgres, redis services)

AI: "Expertise: [1/2/3]"

User: 3

AI: "Detected stack:
- Next.js 14
- PostgreSQL 15 (compose)
- Redis 7 (compose)

Use existing docker-compose.yml? [Y]"

User: Y

AI: "Generated devcontainer.json:

\`\`\`json
{
  "name": "Next.js App",
  "dockerComposeFile": "docker-compose.yml",
  "service": "app",
  "workspaceFolder": "/workspace",
  "customizations": {
    "vscode": {
      "extensions": ["anthropic.claude-code", "bradlc.vscode-tailwindcss"]
    }
  }
}
\`\`\`

Write? [Y]"

User: Y

AI: "Done."
```

**Total questions: 2 (expertise + confirm)**

---

### Implementation Checklist for AI Assistants

Before responding to "Create a devcontainer", verify:

- [ ] Scanned project directory (auto-detection complete)
- [ ] Asked expertise level (gates verbosity)
- [ ] Limited to max questions (4 beginner / 3 intermediate / 2 expert)
- [ ] Provided defaults for every question
- [ ] Showed configuration summary before creating
- [ ] Adapted language to expertise level
- [ ] Only asked what auto-detection couldn't find
- [ ] Included "why it matters" for beginners
- [ ] Gave examples for unclear options
- [ ] Used numbered options (easy to select)

---

### When to Skip the Protocol

**Skip discovery questions and create immediately if:**

1. User provides explicit, complete requirements:
   ```
   "Create a devcontainer with Node 20, PostgreSQL 15, Redis,
   and configure for a team of 10"
   ```

2. User references existing configuration:
   ```
   "Convert my Dockerfile to a devcontainer"
   ```

3. User is migrating from a tutorial/template:
   ```
   "Use the official Python devcontainer template"
   ```

**In these cases:**
- Acknowledge the requirements
- Show what you'll create (summary)
- Create immediately (no questions)

---

### Summary: The Adaptive Discovery Flow

```
┌─────────────────────────────────┐
│  Step 1: Auto-Detect Project   │
│  (Silent - scans files)         │
└───────────┬─────────────────────┘
            │
            ▼
┌─────────────────────────────────┐
│  Step 2: Expertise Gating       │
│  (1 question - determines tone) │
└───────────┬─────────────────────┘
            │
            ├──────────┬──────────────┐
            ▼          ▼              ▼
      Beginner   Intermediate     Expert
    (explain all) (brief context) (minimal)
            │          │              │
            └──────────┴──────────────┘
                       │
                       ▼
┌─────────────────────────────────┐
│  Step 3: Fill Knowledge Gaps    │
│  (2-3 questions max)            │
│  - Project type (if unknown)    │
│  - Services (database, etc.)    │
│  - Team size (conditional)      │
└───────────┬─────────────────────┘
            │
            ▼
┌─────────────────────────────────┐
│  Step 4: Adaptive Follow-ups    │
│  (Only if needed)               │
│  - Prebuilds (large team)       │
│  - Security (.env handling)     │
│  - Optimization (low resources) │
└───────────┬─────────────────────┘
            │
            ▼
┌─────────────────────────────────┐
│  Step 5: Present & Confirm      │
│  (Show config summary)          │
│  - Beginner: Detailed           │
│  - Intermediate: Concise        │
│  - Expert: Minimal              │
└───────────┬─────────────────────┘
            │
            ▼
         Create!
```

---

### Creating Devcontainers

**User Request**: "Create a devcontainer for [technology/stack]"

**IMPORTANT**: Follow the [AI Assistant Discovery Protocol](#ai-assistant-discovery-protocol) before creating. DO NOT immediately create files - ask context-gathering questions first unless user provides explicit complete requirements.

**AI Prompt Template (After Discovery Protocol)**:
```
Based on our conversation, I'll create a devcontainer with:

[Show configuration summary - adapt detail level to expertise]

**For Beginners:**
📦 Configuration Summary:
- [Language/framework + version]
- [Services if any]
- [Extensions: Claude Code + relevant tools]
- Build time: ~X minutes first time, ~2 minutes later

**For Intermediate:**
Config:
- [Stack]
- [Services]
- Extensions: [list]

**For Experts:**
[Stack], [services if any]
Proceed? [Y]

[After approval, create files]
```

**Discovery Protocol Checklist** (Use before creating):
1. ✅ Auto-detect project files (package.json, requirements.txt, etc.)
2. ✅ Ask expertise level (beginner/intermediate/expert)
3. ✅ Confirm detected stack or ask project type
4. ✅ Ask about services/database (if not in docker-compose.yml)
5. ✅ Ask team size (conditional - if appears professional)
6. ✅ Show configuration summary
7. ✅ Get approval before creating files

**Common Stacks** (Reference for Recommended Configs):
- **Node.js/TypeScript**: `node:20` + eslint, prettier, Claude Code
- **Python**: `python:3.11-slim` + pylint, black, ipykernel
- **Full-stack**: Docker Compose with app + database + cache
- **Go**: `golang:1.21` + delve debugger
- **Rust**: `rust:1.75` + rust-analyzer

**When to Skip Protocol** (Create Immediately):
- User provides complete requirements: "Create devcontainer with Node 20, PostgreSQL, Redis for team of 10"
- User references template: "Use official Python devcontainer template"
- Migration scenario: "Convert my Dockerfile to devcontainer"

---

### Debugging Devcontainers

**User Request**: "My devcontainer won't start/build"

**AI Prompt Template**:
```
Let me help debug this. I'll check:
1. Build logs for errors
2. devcontainer.json syntax
3. Dockerfile issues
4. Docker daemon status
5. Resource constraints

First, let me see your devcontainer.json...
```

**Quick Diagnostic Commands**:
```bash
# Check Docker daemon
docker ps

# View build logs
docker build .devcontainer -f .devcontainer/Dockerfile

# Check disk space
docker system df

# Rebuild container
Cmd+Shift+P → "Dev Containers: Rebuild Container"
```

---

### Optimizing Performance

**User Request**: "My devcontainer is slow"

**AI Prompt Template**:
```
I'll optimize your devcontainer performance by:
1. Enabling build cache layers
2. Using volume mounts instead of bind mounts
3. Optimizing lifecycle hooks
4. Configuring platform-specific settings

Let me analyze your current setup...
```

**Optimization Checklist**:
- [ ] Use `.dockerignore` to exclude `node_modules/`, `.git/`
- [ ] Multi-stage Dockerfile with cached layers
- [ ] Named volumes for `node_modules/`, `.npm/`
- [ ] VirtioFS on macOS (Docker Desktop → Experimental)
- [ ] WSL2 filesystem on Windows (not `/mnt/c/`)
- [ ] `postCreateCommand` runs in background (`&`)

---

### Adding MCP Servers

**User Request**: "Add [MCP server name] to my devcontainer"

**AI Prompt Template**:
```
I'll add the [MCP server] to your devcontainer. This involves:
1. Installing dependencies (if stdio transport)
2. Configuring mcp.json
3. Setting up volume persistence
4. Verifying connectivity

Let me update your configuration...
```

**Common MCP Servers**:
```json
{
  "mcpServers": {
    "context7": {
      "transport": {"type": "sse", "url": "https://mcp.context7.com/sse"}
    },
    "cf-docs": {
      "transport": {"type": "sse", "url": "https://docs.mcp.cloudflare.com/sse"}
    },
    "chrome-devtools": {
      "command": "npx",
      "args": ["chrome-devtools-mcp@latest"],
      "transport": {"type": "stdio"}
    }
  }
}
```

---

### Security Configuration

**User Request**: "Make my devcontainer more secure"

**AI Prompt Template**:
```
I'll enhance your devcontainer security by:
1. Running as non-root user
2. Dropping unnecessary capabilities
3. Configuring firewall rules
4. Isolating volumes
5. Using read-only mounts where possible

Let me update your configuration...
```

**Security Hardening**:
```json
{
  "remoteUser": "node",
  "runArgs": [
    "--cap-drop=ALL",
    "--cap-add=NET_BIND_SERVICE",
    "--security-opt=no-new-privileges"
  ],
  "mounts": [
    "source=${localEnv:HOME}/.ssh,target=/home/node/.ssh,type=bind,readonly"
  ]
}
```

---

### Migration to Devcontainers

**User Request**: "Convert my existing project to use devcontainers"

**AI Prompt Template**:
```
I'll migrate your project to devcontainers. This involves:
1. Analyzing your current setup (package.json, requirements.txt, etc.)
2. Choosing appropriate base image
3. Creating .devcontainer/ directory
4. Migrating environment variables
5. Testing the migration

Let me start by examining your project files...
```

**Migration Steps**:
1. Identify language/framework → choose base image
2. List tools installed globally → add to Dockerfile
3. Find env vars (`.env`) → add to `containerEnv`
4. Identify VS Code extensions → add to `customizations.vscode.extensions`
5. Create lifecycle hooks for `npm install`, `pip install`, etc.

---

### Validation and Troubleshooting

**User Request**: "Verify my devcontainer configuration is correct"

**AI Prompt Template**:
```
I'll validate your devcontainer configuration by checking:
1. JSON syntax in devcontainer.json
2. Required properties (image/build, name)
3. Dockerfile best practices
4. Port conflicts
5. Volume mount paths

Let me review your files...
```

**Validation Checklist**:
```bash
# Validate JSON syntax
jq . .devcontainer/devcontainer.json

# Test Dockerfile builds
docker build .devcontainer -f .devcontainer/Dockerfile

# Check for port conflicts
docker ps --format "table {{.Names}}\t{{.Ports}}"

# Verify VS Code extensions exist
code --list-extensions | grep "anthropic.claude-code"
```

---

### Quick Fixes for Common Errors

**Error**: `"Cannot connect to Docker daemon"`
**AI Response**:
```
This means Docker Desktop isn't running. Please:
1. Start Docker Desktop
2. Wait for it to fully start (green whale icon)
3. Retry: Cmd+Shift+P → "Dev Containers: Rebuild Container"
```

**Error**: `"No such file or directory: .devcontainer/devcontainer.json"`
**AI Response**:
```
The .devcontainer/ directory doesn't exist. I'll create it for you:
mkdir -p .devcontainer && cd .devcontainer
Then I'll create a basic devcontainer.json...
```

**Error**: `"ERROR: failed to solve: python:3.11-slim: not found"`
**AI Response**:
```
The base image tag is incorrect. Let me check Docker Hub for valid tags:
- python:3.11-slim ✅
- python:3.11-alpine ✅
- python:3.11 ✅

I'll update your Dockerfile with the correct tag...
```

**Error**: `"EACCES: permission denied, open '/workspaces/...'" `
**AI Response**:
```
This is a file permission issue. I'll fix it by:
1. Setting correct UID/GID in Dockerfile
2. Using remoteUser: "node" (not root)
3. Ensuring volume mounts have correct permissions

Let me update your configuration...
```

---

### Sources

- **VS Code Dev Containers CLI**: https://code.visualstudio.com/docs/devcontainers/devcontainer-cli
- **Common Errors**: https://code.visualstudio.com/docs/devcontainers/troubleshooting
- **Best Practices**: https://code.visualstudio.com/docs/devcontainers/dev best-practices

---

## Common Stack Examples

> Copy-paste these as starting points for common development stacks.

### Example 1: React + Next.js + TypeScript

**devcontainer.json**:
```json
{
  "name": "Next.js Dev",
  "build": {"dockerfile": "Dockerfile"},
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code",
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "bradlc.vscode-tailwindcss"
      ]
    }
  },
  "forwardPorts": [3000],
  "postCreateCommand": "npm install",
  "remoteUser": "node",
  "mounts": [
    "source=claude-${devcontainerId},target=/home/node/.claude,type=volume",
    "source=npm-cache-${devcontainerId},target=/home/node/.npm,type=volume"
  ]
}
```

**Dockerfile**:
```dockerfile
FROM node:20
RUN apt-get update && apt-get install -y git && apt-get clean
USER node
RUN npm install -g @anthropic-ai/claude-code@latest
WORKDIR /workspaces
```

### Example 2: Python Data Science (Jupyter, pandas, numpy)

**devcontainer.json**:
```json
{
  "name": "Python Data Science",
  "build": {"dockerfile": "Dockerfile"},
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code",
        "ms-python.python",
        "ms-toolsai.jupyter"
      ]
    }
  },
  "forwardPorts": [8888],
  "postCreateCommand": "pip install -r requirements.txt",
  "remoteUser": "vscode",
  "mounts": [
    "source=claude-${devcontainerId},target=/home/vscode/.claude,type=volume"
  ]
}
```

**Dockerfile**:
```dockerfile
FROM python:3.11-slim
RUN apt-get update && apt-get install -y git curl && apt-get clean
RUN useradd -m -s /bin/bash vscode
USER vscode
RUN pip install --user jupyterlab pandas numpy matplotlib
RUN curl -fsSL https://deb.nodesource.com/setup_20.x | bash - && \
    apt-get install -y nodejs
RUN npm install -g @anthropic-ai/claude-code@latest
WORKDIR /workspaces
```

### Example 3: Full-Stack (Node.js + PostgreSQL)

See [Multi-Container Patterns](#multi-container-patterns-docker-compose) for Docker Compose setup.

### Example 4: Go + Protobuf

**devcontainer.json**:
```json
{
  "name": "Go Development",
  "build": {"dockerfile": "Dockerfile"},
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code",
        "golang.go"
      ],
      "settings": {
        "go.useLanguageServer": true
      }
    }
  },
  "remoteUser": "vscode",
  "mounts": [
    "source=claude-${devcontainerId},target=/home/vscode/.claude,type=volume",
    "source=go-pkg-${devcontainerId},target=/go/pkg,type=volume"
  ]
}
```

**Dockerfile**:
```dockerfile
FROM golang:1.21
RUN apt-get update && apt-get install -y git curl nodejs npm && apt-get clean
RUN useradd -m -s /bin/bash vscode && \
    mkdir -p /go && chown vscode:vscode /go
USER vscode
RUN npm install -g @anthropic-ai/claude-code@latest
ENV GOPATH=/go
WORKDIR /workspaces
```

---

## Step-by-Step: Creating a Devcontainer

> **AI Assistant Guidance**: When helping users create devcontainers, follow this comprehensive guide including essential configuration files that are often overlooked but critical for performance and security.

This section walks through creating a devcontainer from scratch, with emphasis on proper configuration files that optimize build performance and prevent common pitfalls.

### Quick Overview

**Typical workflow**:
1. Create `.devcontainer/` directory
2. Add essential configuration files (`.dockerignore`, `.gitignore` updates)
3. Create `devcontainer.json`
4. Create `Dockerfile` (or use base image)
5. Test and iterate

**Time to complete**: 10-30 minutes depending on complexity

---

### Essential Configuration Files

Before creating your devcontainer configuration, set up these critical files that dramatically improve build performance, reduce image size, and prevent security issues.

#### .dockerignore - Build Performance & Security

**Purpose**: Excludes files from Docker build context, improving:
- ✅ **Build Speed**: Smaller context = faster uploads to Docker daemon
- ✅ **Image Size**: Prevents accidental inclusion of large files
- ✅ **Security**: Blocks secrets/credentials from entering images
- ✅ **Cache Efficiency**: Reduces layer invalidation

**Location**: Project root (same directory as `docker-compose.yml` or where you run `docker build`)

**How it works**: Similar to `.gitignore`, uses glob patterns to exclude files when building Docker images.

---

##### .dockerignore - Node.js/TypeScript Projects

**.dockerignore**:
```
# Dependencies (will be installed in container)
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
.npm/
.yarn/
.pnp.*

# Testing
coverage/
.nyc_output/
*.lcov

# Build outputs
dist/
build/
out/
.next/
.nuxt/
.cache/

# Environment variables (secrets!)
.env
.env.local
.env.*.local
*.env

# Version control
.git/
.gitignore
.gitattributes

# IDE & Editor
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# CI/CD
.github/
.gitlab-ci.yml
.travis.yml
Jenkinsfile

# Documentation
README.md
CHANGELOG.md
docs/
*.md

# Logs
logs/
*.log
npm-debug.log*

# OS files
.DS_Store
Thumbs.db
Desktop.ini
```

**Key patterns explained**:
- `node_modules/`: Heaviest directory, always rebuilt in container
- `.env*`: Prevents secrets leaking into images
- `.git/`: Large directory, not needed in container
- `dist/`, `build/`: Build outputs, regenerated in container
- `.vscode/`, `.idea/`: IDE configs, vary per developer

---

##### .dockerignore - Python Projects

**.dockerignore**:
```
# Virtual environments (recreated in container)
venv/
env/
ENV/
.venv/
.env/
*.virtualenv

# Python compiled files
__pycache__/
*.py[cod]
*$py.class
*.so
.Python

# Distribution / packaging
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Testing
.pytest_cache/
.tox/
.coverage
.coverage.*
.cache
htmlcov/
*.cover
.hypothesis/

# Jupyter Notebook
.ipynb_checkpoints/
*.ipynb_checkpoints

# Environment variables
.env
.env.*
*.env

# Version control
.git/
.gitignore

# IDE
.vscode/
.idea/
.spyderproject/
.spyproject/
.ropeproject/
*.swp

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Databases (use volumes instead)
*.db
*.sqlite
*.sqlite3

# Logs
*.log
pip-log.txt

# OS files
.DS_Store
Thumbs.db
```

**Key patterns explained**:
- `venv/`, `.venv/`: Virtual environments are container-specific
- `__pycache__/`, `*.pyc`: Compiled Python files, regenerated
- `.pytest_cache/`: Test cache, rebuilt in container
- `*.egg-info/`: Package metadata, recreated during install
- `.ipynb_checkpoints/`: Jupyter temp files, not needed

---

##### .dockerignore - Go Projects

**.dockerignore**:
```
# Binaries
*.exe
*.exe~
*.dll
*.so
*.dylib
bin/
dist/

# Build artifacts
*.test
*.out
/vendor/

# Go workspace
go.work
go.work.sum

# Coverage
*.coverprofile
coverage.txt
coverage.html
*.coverage

# IDE
.vscode/
.idea/
*.swp

# Environment
.env
.env.*

# Version control
.git/
.gitignore

# OS
.DS_Store
Thumbs.db

# Documentation
README.md
docs/
*.md

# CI/CD
.github/
.gitlab-ci.yml
```

**Key patterns explained**:
- `bin/`, `*.exe`: Compiled binaries, built for host OS (not container)
- `/vendor/`: Go dependencies, use `go mod download` in container
- `*.test`, `*.out`: Test binaries, regenerated
- `go.work`: Go workspace file, may conflict with container setup

---

##### .dockerignore - Universal/Multi-Language Projects

**.dockerignore** (comprehensive template for any project):
```
# ===========================
# Version Control
# ===========================
.git/
.gitignore
.gitattributes
.gitmodules
.hg/
.svn/

# ===========================
# CI/CD
# ===========================
.github/
.gitlab-ci.yml
.travis.yml
.circleci/
Jenkinsfile
azure-pipelines.yml
.drone.yml

# ===========================
# IDEs & Editors
# ===========================
.vscode/
.idea/
*.iml
.project
.classpath
.settings/
*.swp
*.swo
*~
.vs/
.vimrc.local

# ===========================
# OS Files
# ===========================
.DS_Store
Thumbs.db
Desktop.ini
$RECYCLE.BIN/
.Trash-*/

# ===========================
# Security (CRITICAL)
# ===========================
.env
.env.*
*.env
.env.local
.env.*.local
secrets/
secret.*
*.key
*.pem
*.crt
*.cer
*.p12
*.pfx
id_rsa*
*.asc
.aws/
.ssh/
credentials

# ===========================
# Dependencies (Language-specific)
# ===========================
# Node.js
node_modules/
.npm/
.yarn/
# Python
venv/
.venv/
__pycache__/
*.pyc
# Go
vendor/
# Ruby
.bundle/
# PHP
vendor/
# Rust
target/
# Java
.gradle/
.m2/

# ===========================
# Build Artifacts
# ===========================
dist/
build/
out/
bin/
*.exe
*.dll
*.so
*.dylib
*.jar
*.war
*.ear

# ===========================
# Logs & Temporary Files
# ===========================
logs/
*.log
*.log.*
tmp/
temp/
cache/
.cache/

# ===========================
# Testing & Coverage
# ===========================
coverage/
.coverage
htmlcov/
.nyc_output/
.pytest_cache/
.tox/

# ===========================
# Documentation
# ===========================
README.md
CHANGELOG.md
CONTRIBUTING.md
LICENSE
docs/
*.md

# ===========================
# Devcontainer-Specific
# ===========================
# Include these - needed for build!
!.devcontainer/
!.devcontainer/**

# ===========================
# Docker-in-Docker
# ===========================
.docker/
docker-compose.override.yml
```

**Critical security patterns**:
- `.env*`: Environment files may contain API keys, passwords
- `*.key`, `*.pem`: Private keys and certificates
- `.ssh/`: SSH keys
- `.aws/`: AWS credentials
- `secrets/`: Any secrets directory

**Performance patterns**:
- `node_modules/`: Can be 500MB+, slowest part of context copy
- `.git/`: Often 100MB+, not needed in image
- `dist/`, `build/`: Large build outputs, regenerated
- Documentation: `*.md`, `docs/` not needed at runtime

---

##### .dockerignore Best Practices

1. **Start Specific, Then Add Wildcards**
   ```
   # Good (specific)
   .env.local
   .env.development.local

   # Better (catches all)
   .env*
   ```

2. **Use Negative Patterns to Include Exceptions**
   ```
   # Exclude all markdown
   *.md

   # But include README in Docker image
   !README.md
   ```

3. **Order Matters** (first match wins)
   ```
   # Exclude all, then include specific
   secrets/*
   !secrets/public-cert.pem
   ```

4. **Test Your .dockerignore**
   ```bash
   # See what Docker will copy
   docker build --no-cache --progress=plain . 2>&1 | grep "COPY"

   # Or check context size
   docker build --no-cache . 2>&1 | grep "sending build context"
   ```

5. **Measure Impact**
   ```bash
   # Before adding .dockerignore
   time docker build .
   # => Sending build context: 2.3GB (60 seconds)

   # After optimized .dockerignore
   time docker build .
   # => Sending build context: 45MB (3 seconds)
   ```

---

#### .gitignore - Version Control for Devcontainers

**Purpose**: Controls what gets committed to version control. For devcontainers, this has special considerations.

**Location**: Project root

---

##### .gitignore - Devcontainer-Specific Patterns

**.gitignore** (additions for devcontainer projects):
```
# ===========================
# DO COMMIT (Important!)
# ===========================
# These should be committed for team collaboration
# .devcontainer/          ← NEVER ignore this!
# .devcontainer/*.json    ← NEVER ignore configs!
# .devcontainer/Dockerfile ← NEVER ignore this!

# ===========================
# DO IGNORE (Personal Settings)
# ===========================
# Local overrides (personal preferences)
.devcontainer/devcontainer.local.json
.devcontainer/.env.local
.devcontainer/docker-compose.override.yml

# User-specific VS Code settings
.vscode/settings.local.json

# Personal Claude Code settings (contains API keys!)
.claude/settings.local.json
.claude/cache/
.claude/logs/

# Personal MCP server configs (may contain tokens)
.claude/mcp.local.json

# ===========================
# Docker Build Artifacts
# ===========================
# Docker layer cache (if using local cache)
.devcontainer/.docker-cache/

# ===========================
# Volume Data (DO NOT COMMIT)
# ===========================
# Named volume contents (if accidentally created locally)
.docker-volumes/
volumes/

# Database data (use volumes instead)
postgres-data/
mysql-data/
redis-data/

# ===========================
# Standard Patterns
# ===========================
# Environment variables
.env
.env.local
.env.*.local

# Secrets
secrets/
*.key
*.pem

# OS
.DS_Store
Thumbs.db

# IDE
.vscode/*
!.vscode/extensions.json
!.vscode/settings.json
!.vscode/tasks.json
.idea/
```

---

##### .gitignore - Common Mistakes

**❌ MISTAKE #1: Ignoring .devcontainer/ Entirely**
```
# WRONG - breaks team collaboration!
.devcontainer/
```

**Why it's wrong**: Team members won't get your devcontainer setup. The whole point is to share the environment.

**✅ Correct approach**:
```
# Commit the configs
# (no ignore rule)

# Only ignore personal overrides
.devcontainer/devcontainer.local.json
.devcontainer/.env.local
```

---

**❌ MISTAKE #2: Committing Personal Settings**
```
# Missing from .gitignore
.claude/settings.local.json
```

**Why it's wrong**: Contains API keys, personal preferences, and credentials.

**✅ Correct approach**:
```
# In .gitignore
.claude/settings.local.json
.claude/cache/
.claude/logs/

# In .devcontainer/
.claude/settings.json.template  ← Commit this (template without secrets)
```

---

**❌ MISTAKE #3: Ignoring Lock Files**
```
# WRONG
package-lock.json
yarn.lock
poetry.lock
Gemfile.lock
```

**Why it's wrong**: Lock files ensure reproducible builds. Without them, `npm install` might install different versions for different developers.

**✅ Correct approach**:
```
# Commit lock files for reproducibility
# (no ignore rule needed)
```

---

##### .gitignore - Language-Specific Additions

**Node.js projects** (add to standard .gitignore):
```
# Dependencies
node_modules/

# Build outputs
dist/
build/

# Logs
npm-debug.log*
yarn-debug.log*
```

**Python projects** (add to standard .gitignore):
```
# Virtual environments
venv/
.venv/
env/

# Compiled Python
__pycache__/
*.pyc
*.pyo

# Distribution
dist/
*.egg-info/
```

**Go projects** (add to standard .gitignore):
```
# Binaries
bin/
*.exe

# Vendor (if using modules, don't commit vendor/)
vendor/

# Build artifacts
*.test
```

---

##### .gitignore Decision Tree

```
Is it a devcontainer config file?
├─ devcontainer.json, Dockerfile, docker-compose.yml
│   → COMMIT (team needs it)
│
├─ devcontainer.local.json, .env.local
│   → IGNORE (personal overrides)
│
└─ init scripts, setup.sh
    → COMMIT (part of automated setup)

Is it a personal setting or credential?
├─ .claude/settings.local.json, API keys, tokens
│   → IGNORE (sensitive data)
│
├─ .vscode/settings.json
│   → COMMIT (team workspace settings)
│
└─ .vscode/settings.local.json
    → IGNORE (personal preferences)

Is it generated by tools?
├─ node_modules/, venv/, __pycache__
│   → IGNORE (regenerated from lock files)
│
├─ package-lock.json, poetry.lock
│   → COMMIT (ensures reproducibility)
│
└─ dist/, build/, *.pyc
    → IGNORE (build artifacts)
```

---

### Step-by-Step Creation Process

Now that you understand essential configuration files, follow these steps to create a complete devcontainer.

#### Step 1: Create Directory Structure

```bash
# From project root
mkdir -p .devcontainer
cd .devcontainer
```

**Result**:
```
your-project/
├── .devcontainer/    ← New directory
└── [your existing files]
```

---

#### Step 2: Create .dockerignore (Project Root)

```bash
# Return to project root
cd ..

# Create .dockerignore based on your language
# (Use examples from "Essential Configuration Files" above)
```

**For Node.js**:
```bash
cat > .dockerignore << 'EOF'
node_modules/
.npm/
dist/
.env*
.git/
.vscode/
README.md
*.log
EOF
```

**For Python**:
```bash
cat > .dockerignore << 'EOF'
venv/
.venv/
__pycache__/
*.pyc
.env*
.git/
.vscode/
*.log
EOF
```

---

#### Step 3: Update .gitignore

```bash
# Add devcontainer-specific patterns
cat >> .gitignore << 'EOF'

# Devcontainer personal settings
.devcontainer/devcontainer.local.json
.devcontainer/.env.local
.claude/settings.local.json
.claude/cache/
.claude/logs/
EOF
```

**Verify .devcontainer/ is NOT ignored**:
```bash
# This should return nothing
grep "^\.devcontainer/$" .gitignore

# If it returns a match, remove that line!
```

---

#### Step 4: Create devcontainer.json

Choose your approach:

**Option A: Use Base Image (Fastest)**
```bash
cat > .devcontainer/devcontainer.json << 'EOF'
{
  "name": "My Dev Container",
  "image": "node:20",
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code"
      ]
    }
  },
  "postCreateCommand": "npm install",
  "remoteUser": "node",
  "mounts": [
    "source=claude-${devcontainerId},target=/home/node/.claude,type=volume"
  ]
}
EOF
```

**Option B: Use Dockerfile (Custom)**
```bash
cat > .devcontainer/devcontainer.json << 'EOF'
{
  "name": "My Dev Container",
  "build": {
    "dockerfile": "Dockerfile"
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code"
      ]
    }
  },
  "postCreateCommand": "npm install",
  "remoteUser": "node",
  "mounts": [
    "source=claude-${devcontainerId},target=/home/node/.claude,type=volume"
  ]
}
EOF
```

---

#### Step 5: Create Dockerfile (If Using Option B)

```bash
cat > .devcontainer/Dockerfile << 'EOF'
FROM node:20

# Install system packages
RUN apt-get update && \
    apt-get install -y git curl && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/*

# Switch to non-root user
USER node

# Install Claude Code globally
RUN npm install -g @anthropic-ai/claude-code@latest

WORKDIR /workspaces
EOF
```

---

#### Step 6: Validate Configuration

```bash
# Check JSON syntax
jq . .devcontainer/devcontainer.json

# Verify .dockerignore exists
ls -la .dockerignore

# Verify .devcontainer/ will be committed
git status .devcontainer/
# Should show: new file: .devcontainer/devcontainer.json
```

---

#### Step 7: Test the Devcontainer

**In VS Code**:
1. Open Command Palette: `Cmd+Shift+P` (Mac) / `Ctrl+Shift+P` (Windows/Linux)
2. Select: `Dev Containers: Reopen in Container`
3. Wait for build to complete (5-15 minutes first time)
4. Verify terminal opens inside container:
   ```bash
   # Check you're inside container
   hostname
   # => Should show container ID (e.g., a1b2c3d4e5f6)

   # Check Node version
   node --version
   # => Should show v20.x.x

   # Check Claude Code installed
   claude --version
   ```

---

#### Step 8: Commit Your Configuration

```bash
# Stage devcontainer files
git add .devcontainer/
git add .dockerignore
git add .gitignore

# Commit
git commit -m "Add devcontainer configuration

- Node.js 20 base image
- Claude Code pre-installed
- Optimized .dockerignore for build performance
- Updated .gitignore for devcontainer personal settings"

# Push to remote
git push
```

**Team members can now**:
```bash
git pull
code .
# Click "Reopen in Container"
# Start coding immediately!
```

---

### Validation Checklist

Before sharing with your team, verify:

- [ ] `.dockerignore` exists and excludes `node_modules/`, `.git/`, `dist/`
- [ ] `.gitignore` does NOT ignore `.devcontainer/` directory
- [ ] `.gitignore` DOES ignore `.claude/settings.local.json`
- [ ] `devcontainer.json` has valid JSON syntax
- [ ] `devcontainer.json` includes necessary VS Code extensions
- [ ] Container builds successfully (`docker build .devcontainer`)
- [ ] Container starts and you can open a terminal inside it
- [ ] Tools are accessible (e.g., `node --version`, `python --version`)
- [ ] Volumes persist data across rebuilds (test: create file, rebuild, check file exists)
- [ ] Port forwarding works (test: run dev server, access from host browser)

---

### Quick Troubleshooting

**Build is slow (>10 minutes)**:
- ✅ Check `.dockerignore` excludes `node_modules/`, `.git/`
- ✅ Verify Docker Desktop has sufficient resources (Settings → Resources)
- ✅ Use multi-stage Dockerfile to cache dependencies

**"Permission denied" errors**:
- ✅ Ensure `remoteUser` matches Dockerfile user (e.g., `"remoteUser": "node"`)
- ✅ Verify volume mounts target user's home directory (`/home/node`)

**.devcontainer/ changes not reflected**:
- ✅ Rebuild container: `Cmd+Shift+P` → `Dev Containers: Rebuild Container`
- ✅ Don't just "Reopen in Container" (uses cached image)

**API keys not working**:
- ✅ Check `.env` is NOT in `.dockerignore` (if needed during build)
- ✅ Use `containerEnv` or `remoteEnv` in `devcontainer.json` for runtime vars
- ✅ Ensure `.env.local` is in `.gitignore` (don't commit secrets!)

---

### Next Steps

Once your devcontainer is working:

1. **Add MCP servers**: See [MCP Server Setup](#mcp-server-setup)
2. **Optimize performance**: See [Resource and Performance Considerations](#resource-and-performance-considerations)
3. **Set up CI/CD**: See [Prebuild Images & CI/CD Automation](#prebuild-images--cicd-automation)
4. **Enhance security**: See [Security Best Practices](#security-best-practices)
5. **Create team template**: See [Creating & Distributing Templates](#creating--distributing-templates)

---

## Prebuild Images & CI/CD Automation

> **AI Assistant Guidance**: Prebuild images dramatically improve devcontainer startup time and enable enterprise-scale adoption. Recommend prebuilds for teams with >3 developers or complex build processes.

**Official Guide**: https://containers.dev/guide/prebuild

### What Are Prebuild Images?

**Prebuild images** are pre-constructed container images that package all dependencies, tools, and configurations needed for a development environment. Instead of building from scratch each time a developer opens a project, they **pull an already-built image**.

**Analogy**: Like using a Docker image vs. compiling from source every time.

### The Problem Prebuilds Solve

**Without prebuilds**:
```
Developer 1: Opens project → Builds from Dockerfile (15 min) → Starts coding
Developer 2: Opens project → Builds from Dockerfile (15 min) → Starts coding
Developer 3: Opens project → Builds from Dockerfile (15 min) → Starts coding
Developer 4: Opens project → Builds from Dockerfile (15 min) → Starts coding

Total wasted time: 60 minutes
```

**With prebuilds**:
```
CI/CD: Builds image once (15 min) → Pushes to registry
Developer 1: Opens project → Pulls prebuild (2 min) → Starts coding
Developer 2: Opens project → Pulls prebuild (2 min) → Starts coding
Developer 3: Opens project → Pulls prebuild (2 min) → Starts coding
Developer 4: Opens project → Pulls prebuild (2 min) → Starts coding

Total time: 15 min (CI) + 8 min (team) = 23 minutes
Savings: 60% faster for team
```

### Why Use Prebuild Images?

#### 1. **Speed**
- Eliminates build time (potentially hours for complex stacks)
- Developers start coding in 1-2 minutes vs. 10-60 minutes
- New team members productive immediately

#### 2. **Consistency**
- All developers use **identical** environments
- No "works on my machine" issues
- Pinned dependency versions

#### 3. **Security**
- Pin specific tool versions for supply-chain security
- Scan images for vulnerabilities before distribution
- Control exactly what's in the environment

#### 4. **Simplicity**
- `devcontainer.json` can be just:
  ```json
  {
    "image": "ghcr.io/myorg/myproject-devcontainer:latest"
  }
  ```
- No Dockerfile management per project
- Single source of truth for environment

### Creating Prebuild Images

#### Prerequisites

Install the Dev Container CLI:
```bash
npm install -g @devcontainers/cli
```

**Docs**: https://github.com/devcontainers/cli

#### Step 1: Configure Your Devcontainer

Your project has a working `.devcontainer/` setup:
```
.devcontainer/
├── devcontainer.json
└── Dockerfile
```

#### Step 2: Build the Prebuild Image

```bash
# Build and push to registry
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name ghcr.io/myorg/myproject-devcontainer:1.0.0
```

**Explanation**:
- `--workspace-folder .`: Project root directory
- `--push true`: Push to registry after building
- `--image-name`: Full image name with tag

**Alternative (build only, no push)**:
```bash
devcontainer build \
  --workspace-folder . \
  --image-name myproject-devcontainer:latest
```

#### Step 3: Update devcontainer.json

Replace Dockerfile reference with image reference:

**Before (build from Dockerfile)**:
```json
{
  "name": "My Project",
  "build": {
    "dockerfile": "Dockerfile"
  }
}
```

**After (use prebuild)**:
```json
{
  "name": "My Project",
  "image": "ghcr.io/myorg/myproject-devcontainer:1.0.0"
}
```

### Publishing to Registries

#### GitHub Container Registry (GHCR)

**Authentication**:
```bash
# Create Personal Access Token (PAT) with write:packages scope
# https://github.com/settings/tokens

# Login to GHCR
echo $GHCR_TOKEN | docker login ghcr.io -u USERNAME --password-stdin
```

**Build and push**:
```bash
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name ghcr.io/myorg/myproject-devcontainer:1.0.0
```

**Image URL**: `ghcr.io/<org>/<repo>/<image>:<tag>`

**Official Docs**: https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry

---

#### Azure Container Registry (ACR)

**Authentication**:
```bash
az login
az acr login --name myregistry
```

**Build and push**:
```bash
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name myregistry.azurecr.io/myproject-devcontainer:1.0.0
```

**Official Docs**: https://learn.microsoft.com/en-us/azure/container-registry/

---

#### Docker Hub

**Authentication**:
```bash
docker login
```

**Build and push**:
```bash
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name myusername/myproject-devcontainer:1.0.0
```

**Image URL**: `docker.io/<username>/<image>:<tag>` or simply `<username>/<image>:<tag>`

**Official Docs**: https://docs.docker.com/docker-hub/

---

### GitHub Actions Automation

Automate prebuild creation on every commit or PR.

#### Official GitHub Action

**Action**: https://github.com/marketplace/actions/dev-container-build-and-run-action

**.github/workflows/devcontainer-prebuild.yml**:
```yaml
name: Build Dev Container Prebuild

on:
  push:
    branches: [main]
    paths:
      - '.devcontainer/**'
  pull_request:
    paths:
      - '.devcontainer/**'
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pre-build dev container image
        uses: devcontainers/ci@v0.3
        with:
          imageName: ghcr.io/${{ github.repository }}/devcontainer
          cacheFrom: ghcr.io/${{ github.repository }}/devcontainer
          push: always
```

**Key features**:
- **Triggers**: Runs when `.devcontainer/` changes
- **Authentication**: Uses automatic `GITHUB_TOKEN`
- **Caching**: Uses previous builds for speed
- **Push**: Always pushes to GHCR

**Official Docs**: https://github.com/devcontainers/ci

---

#### Azure DevOps Pipeline

**Task**: https://marketplace.visualstudio.com/items?itemName=devcontainers.ci

**azure-pipelines.yml**:
```yaml
trigger:
  paths:
    include:
      - .devcontainer/*

pool:
  vmImage: 'ubuntu-latest'

steps:
  - task: DevContainersCi@1
    inputs:
      imageName: '$(imageRegistry)/$(imageName)'
      push: 'always'
      cacheFrom: '$(imageRegistry)/$(imageName)'
```

---

### Official Prebuild Images

Microsoft maintains official prebuild images for common stacks.

**Registry**: `mcr.microsoft.com/devcontainers/*`

#### Popular Official Images

**Node.js**:
```json
{
  "image": "mcr.microsoft.com/devcontainers/typescript-node:20"
}
```

**Python**:
```json
{
  "image": "mcr.microsoft.com/devcontainers/python:3.11"
}
```

**Go**:
```json
{
  "image": "mcr.microsoft.com/devcontainers/go:1.21"
}
```

**Rust**:
```json
{
  "image": "mcr.microsoft.com/devcontainers/rust:latest"
}
```

**Universal (multi-language)**:
```json
{
  "image": "mcr.microsoft.com/devcontainers/universal:latest"
}
```

**Full catalog**: https://github.com/devcontainers/images

---

### Prebuild vs Dockerfile Comparison

| Aspect | Dockerfile (Build) | Prebuild Image |
|--------|-------------------|----------------|
| **First-time setup** | 5-60 minutes | 1-2 minutes |
| **Subsequent opens** | 0-5 minutes (cached) | 1-2 minutes |
| **Team consistency** | Depends on Docker cache | Guaranteed identical |
| **Security** | Build-time vulnerabilities | Scan before distribution |
| **CI/CD integration** | Builds in pipeline | Pre-built, just test |
| **Disk space (local)** | One layer cache per dev | One image shared |
| **Customization** | Full control | Limited to runtime config |
| **Best for** | Rapid iteration, custom needs | Team standardization, speed |

---

### Versioning Strategy

**Semantic Versioning** recommended:

```bash
# Major version (breaking changes)
ghcr.io/myorg/myproject:2.0.0

# Minor version (new features)
ghcr.io/myorg/myproject:1.1.0

# Patch version (bug fixes)
ghcr.io/myorg/myproject:1.0.1

# Latest (rolling)
ghcr.io/myorg/myproject:latest
```

**Best practice**: Pin to specific version in devcontainer.json, use `latest` for testing:

```json
{
  "image": "ghcr.io/myorg/myproject:1.2.3"
}
```

---

### Multi-stage Dockerfiles: Dev → Production

Use same Dockerfile for dev prebuilds and production images:

**Dockerfile**:
```dockerfile
# Development stage
FROM node:20 AS development
RUN apt-get update && apt-get install -y git vim curl
RUN npm install -g @anthropic-ai/claude-code@latest
COPY package*.json ./
RUN npm install
COPY . .

# Production stage (smaller, optimized)
FROM node:20-slim AS production
WORKDIR /app
COPY --from=development /app/dist ./dist
COPY --from=development /app/package*.json ./
RUN npm ci --only=production
CMD ["node", "dist/index.js"]
```

**devcontainer.json** (use dev stage):
```json
{
  "build": {
    "dockerfile": "Dockerfile",
    "target": "development"
  }
}
```

**Prebuild command** (build dev stage):
```bash
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name ghcr.io/myorg/myproject-devcontainer:1.0.0
```

**Docker build** (production):
```bash
docker build --target production -t myorg/myproject:1.0.0 .
```

---

### Image Labels & Metadata

Include metadata via Docker labels for self-contained images:

**Dockerfile**:
```dockerfile
LABEL org.opencontainers.image.source="https://github.com/myorg/myproject"
LABEL org.opencontainers.image.description="Development environment for MyProject"
LABEL org.opencontainers.image.version="1.0.0"
LABEL devcontainer.metadata='{"features":{"node":"20","python":"3.11"}}'
```

**View labels**:
```bash
docker inspect ghcr.io/myorg/myproject:1.0.0 | jq '.[0].Config.Labels'
```

---

### CI/CD Integration Patterns

#### Pattern 1: Nightly Builds
Update prebuilds nightly to include latest security patches:

```yaml
on:
  schedule:
    - cron: '0 2 * * *'  # 2 AM daily
```

#### Pattern 2: PR Preview Environments
Build unique prebuild per PR for testing:

```yaml
imageName: ghcr.io/${{ github.repository }}/devcontainer:pr-${{ github.event.pull_request.number }}
```

#### Pattern 3: Multi-platform Builds
Build for ARM64 (M1/M2 Macs) and AMD64:

```yaml
- name: Set up Docker Buildx
  uses: docker/setup-buildx-action@v3

- name: Build multi-platform image
  run: |
    devcontainer build \
      --workspace-folder . \
      --platform linux/amd64,linux/arm64 \
      --push true \
      --image-name ghcr.io/myorg/myproject:latest
```

---

### Best Practices

1. **Use Features**: Organize dependencies as Features for modularity
2. **Layer Caching**: Order Dockerfile commands by change frequency (rare → frequent)
3. **Security Scanning**: Scan images with `trivy` or `snyk` before pushing
4. **Documentation**: Include README in image describing contents
5. **Tagging**: Use semantic versioning + `latest` tag
6. **Size Optimization**: Use slim/alpine base images when possible
7. **Testing**: Test prebuild in CI before distributing to team

---

### Example: Complete Prebuild Workflow

**1. Initial Setup**

**.devcontainer/devcontainer.json**:
```json
{
  "name": "MyProject Dev",
  "build": {
    "dockerfile": "Dockerfile"
  },
  "features": {
    "ghcr.io/devcontainers/features/node:1": {"version": "20"},
    "ghcr.io/devcontainers/features/docker-in-docker:2": {}
  },
  "customizations": {
    "vscode": {
      "extensions": ["anthropic.claude-code"]
    }
  }
}
```

**.devcontainer/Dockerfile**:
```dockerfile
FROM node:20
RUN apt-get update && apt-get install -y git && apt-get clean
USER node
RUN npm install -g @anthropic-ai/claude-code@latest
```

**2. Build Prebuild Locally**

```bash
devcontainer build \
  --workspace-folder . \
  --image-name myproject-dev:test

# Test locally
docker run -it myproject-dev:test bash
```

**3. Push to Registry**

```bash
# Login
echo $GHCR_TOKEN | docker login ghcr.io -u myusername --password-stdin

# Build and push
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name ghcr.io/myorg/myproject-dev:1.0.0
```

**4. Update devcontainer.json**

```json
{
  "name": "MyProject Dev",
  "image": "ghcr.io/myorg/myproject-dev:1.0.0",
  "customizations": {
    "vscode": {
      "extensions": ["anthropic.claude-code"]
    }
  }
}
```

**5. Set Up GitHub Actions**

**.github/workflows/devcontainer-prebuild.yml**: (see earlier example)

**6. Team Usage**

Team members simply:
```bash
git clone https://github.com/myorg/myproject
code myproject
# Click "Reopen in Container"
# 2 minutes later, ready to code!
```

---

### Sources
- **Official Prebuild Guide**: https://containers.dev/guide/prebuild
- **Dev Container CLI**: https://github.com/devcontainers/cli
- **CLI Documentation**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md
- **GitHub Actions**: https://github.com/devcontainers/ci
- **Official Images**: https://github.com/devcontainers/images
- **Azure DevOps Task**: https://marketplace.visualstudio.com/items?itemName=devcontainers.ci

---


---

## Creating & Distributing Templates

> **AI Assistant Guidance**: Templates enable rapid project bootstrapping and organization-wide standardization. Recommend templates for platform teams, large organizations, and open-source communities.

**Official Specification**: https://containers.dev/implementors/templates-distribution/

### What Are Devcontainer Templates?

**Dev Container Templates** are reusable, pre-configured development environment packages that can be distributed and applied to projects. They enable:

- **Rapid Project Bootstrapping**: Initialize new projects with complete devcontainer configs
- **Organization Standards**: Share company-wide development environment patterns
- **Community Sharing**: Distribute best practices publicly
- **Self-Service**: Developers discover and apply templates through VS Code UI

**Analogy**: Like project templates in IDEs (e.g., "Create React App"), but for entire development environments.

### Templates vs Prebuild Images vs Features

| Aspect | Template | Prebuild Image | Feature |
|--------|----------|----------------|---------|
| **What** | Full devcontainer config + files | Pre-built container image | Modular tool installation |
| **Contains** | devcontainer.json + scripts + docs | OS + tools + dependencies | Single tool/capability |
| **When to use** | Starting new project | Team standardization | Adding capability to existing setup |
| **Distribution** | OCI registry as tarball | Container registry as image | OCI registry as tarball |
| **Customization** | Template options (prompts) | Limited (runtime only) | Feature options |
| **User interaction** | Apply once at project creation | Pull on every container start | Declared in devcontainer.json |
| **Example** | "Python FastAPI project" | `mcr.microsoft.com/devcontainers/python:3.11` | `ghcr.io/devcontainers/features/python:1` |

---

### Template Structure

Templates follow a standardized directory organization:

```
src/
├── my-template/                        # Template ID
│   ├── devcontainer-template.json     # Metadata (required)
│   ├── .devcontainer/                 # Config directory (required)
│   │   ├── devcontainer.json          # Devcontainer config
│   │   ├── Dockerfile                 # Optional custom image
│   │   └── docker-compose.yml         # Optional compose file
│   ├── .vscode/                       # Optional VS Code settings
│   │   └── settings.json
│   ├── scripts/                       # Optional helper scripts
│   │   └── setup.sh
│   ├── README.md                      # Optional documentation
│   └── [additional files]             # Any other files to include
```

**Key files**:
1. **devcontainer-template.json**: Template metadata
2. **.devcontainer/devcontainer.json**: The actual devcontainer configuration
3. **Any additional files**: Copied to project when template is applied

---

### Creating a Template from Scratch

#### Step 1: Use Template Starter Repository

The official template starter provides a complete scaffold:

```bash
# Clone template starter
git clone https://github.com/devcontainers/template-starter.git my-templates
cd my-templates
```

**Repository**: https://github.com/devcontainers/template-starter

**Structure provided**:
```
my-templates/
├── src/                    # Your templates go here
│   ├── color/             # Example template
│   └── hello/             # Another example
├── test/                   # Template tests
└── .github/workflows/      # Automated publishing
```

---

#### Step 2: Create Template Metadata

**src/my-python-template/devcontainer-template.json**:

```json
{
  "id": "my-python-template",
  "version": "1.0.0",
  "name": "Python FastAPI Project",
  "description": "FastAPI project with PostgreSQL, Redis, and testing setup",
  "documentationURL": "https://github.com/myorg/templates/tree/main/src/my-python-template",
  "publisher": "MyOrg",
  "licenseURL": "https://github.com/myorg/templates/blob/main/LICENSE",
  "options": {
    "pythonVersion": {
      "type": "string",
      "description": "Python version",
      "proposals": ["3.11", "3.10", "3.9"],
      "default": "3.11"
    },
    "includeDocker": {
      "type": "boolean",
      "description": "Include Docker-in-Docker support",
      "default": false
    },
    "database": {
      "type": "string",
      "description": "Database to include",
      "proposals": ["postgres", "mysql", "none"],
      "default": "postgres"
    }
  }
}
```

**Key fields**:
- **id**: Unique identifier (used in OCI registry path)
- **version**: Semantic version (1.0.0, 2.1.3, etc.)
- **name**: Human-readable display name
- **description**: Shown in template picker
- **options**: User-configurable parameters with defaults

**Official Metadata Spec**: https://containers.dev/implementors/templates/#devcontainer-template.json-properties

---

#### Step 3: Create Devcontainer Configuration

**src/my-python-template/.devcontainer/devcontainer.json**:

```json
{
  "name": "Python FastAPI Project",
  "image": "mcr.microsoft.com/devcontainers/python:${templateOption:pythonVersion}",
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "enableNonRootDocker": "true"
    }
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "ms-python.python",
        "ms-python.vscode-pylance",
        "charliermarsh.ruff"
      ]
    }
  },
  "forwardPorts": [8000],
  "postCreateCommand": "pip install -r requirements.txt",
  "remoteUser": "vscode"
}
```

**Template variables**:
- `${templateOption:optionName}`: Replaced with user-selected option value
- `${templateOption:pythonVersion}` → `"3.11"` (from user choice)

---

#### Step 4: Add Supporting Files

**src/my-python-template/requirements.txt**:
```
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
pytest==7.4.3
```

**src/my-python-template/docker-compose.yml** (if database option selected):
```yaml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_USER: devuser
      POSTGRES_PASSWORD: devpass
      POSTGRES_DB: devdb
    volumes:
      - postgres-data:/var/lib/postgresql/data

volumes:
  postgres-data:
```

**src/my-python-template/README.md**:
```markdown
# Python FastAPI Template

This template provides a complete FastAPI development environment with:
- Python ${templateOption:pythonVersion}
- PostgreSQL database
- Testing with pytest
- Linting with Ruff

### Getting Started with Templates (Official Examples)

1. Start the dev container
2. Run `uvicorn main:app --reload`
3. Open http://localhost:8000
```

---

#### Step 5: Test Template Locally

```bash
# Install Dev Container CLI
npm install -g @devcontainers/cli

# Test template application
devcontainer templates apply \
  --template-id my-python-template \
  --template-args '{"pythonVersion": "3.11", "database": "postgres"}' \
  --workspace-folder ./test-project
```

This creates `test-project/.devcontainer/` with your template applied.

---

### Publishing Templates

Templates are distributed as **tarballs** to **OCI registries** (same infrastructure as Docker images).

#### Packaging

Templates are packaged following the naming convention:
```
devcontainer-template-<id>.tgz
```

**Tarball contents**:
- devcontainer-template.json
- .devcontainer/devcontainer.json
- All additional files in template directory

**Media type**: `application/vnd.devcontainers.layer.v1+tar`

---

#### Publishing to GitHub Container Registry (GHCR)

**Prerequisites**:
1. GitHub repository with templates in `src/` directory
2. GitHub Personal Access Token with `write:packages` scope
3. Dev Container CLI installed

**Manual publish**:

```bash
# Set authentication
export GITHUB_TOKEN="your-pat-token"

# Publish all templates in src/
devcontainer templates publish \
  -r ghcr.io \
  -n myorg/templates \
  ./src
```

**Result**: Templates published to:
```
ghcr.io/myorg/templates/my-python-template:1.0.0
ghcr.io/myorg/templates/my-node-template:1.0.0
```

**Official CLI Docs**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md#templates-publish

---

#### Automated Publishing with GitHub Actions

The template-starter repository includes pre-configured GitHub Actions.

**.github/workflows/release.yml** (provided by template-starter):

```yaml
name: Release Templates

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  publish:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Publish templates to GHCR
        uses: devcontainers/action@v1
        with:
          publish-templates: "true"
          base-path-to-templates: "./src"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Trigger**: Automatically publishes on every push to `main`.

**Authentication**: Uses automatic `GITHUB_TOKEN` (no manual PAT needed).

---

#### Publishing to Private Registries

**Azure Container Registry (ACR)**:
```bash
# Login
az acr login --name myregistry

# Publish
devcontainer templates publish \
  -r myregistry.azurecr.io \
  -n templates \
  ./src
```

**Docker Hub**:
```bash
# Login
docker login

# Publish
devcontainer templates publish \
  -r docker.io \
  -n myusername/templates \
  ./src
```

---

### Consuming Templates

#### Via VS Code UI

**For Users**:

1. **Command Palette** (`Cmd+Shift+P` / `Ctrl+Shift+P`)
2. Type: **"Dev Containers: Add Dev Container Configuration Files"**
3. Select **"Show All Definitions"**
4. Search for your template (e.g., "Python FastAPI")
5. Select template
6. Configure options (Python version, database, etc.)
7. VS Code applies template to `.devcontainer/`

**Discovery**: VS Code automatically discovers templates from:
- Official registry (`ghcr.io/devcontainers/templates/*`)
- Community templates (popular public repos)
- Your organization's registry (if configured)

---

#### Via CLI

**Apply template to existing project**:

```bash
devcontainer templates apply \
  -t ghcr.io/myorg/templates/my-python-template \
  -a '{"pythonVersion": "3.11", "database": "postgres"}' \
  -w .
```

**Flags**:
- `-t, --template-id`: Template identifier (registry path or local path)
- `-a, --template-args`: JSON object with option values
- `-w, --workspace-folder`: Target directory (`.` for current)

**Result**: Creates `.devcontainer/` with template applied.

---

#### In GitHub Codespaces

**Automatic**: When opening a repository in Codespaces, if it has `.devcontainer/`, Codespaces uses it.

**Manual template selection**:
1. Open repository in browser
2. Click **"Code"** → **"Codespaces"** → **"..."** → **"New with options"**
3. Select dev container configuration template
4. Customize options
5. Create Codespace

Codespaces applies template and builds environment in the cloud.

---

### Official Templates Repository

**Repository**: https://github.com/devcontainers/templates
**Registry**: `ghcr.io/devcontainers/templates/*`
**Browser**: https://containers.dev/templates

#### Popular Official Templates

**Language Templates**:
- `alpine` - Minimal Alpine Linux
- `dotnet` - .NET development
- `go` - Go toolchain
- `java` - Java with Maven/Gradle
- `javascript-node` - Node.js
- `php` - PHP with Composer
- `python` - Python 3
- `ruby` - Ruby
- `rust` - Rust
- `typescript-node` - TypeScript + Node.js

**Framework Templates**:
- `docker-from-docker` - Docker-in-Docker
- `docker-outside-of-docker` - Docker from host
- `kubernetes-helm` - Kubernetes development
- `anaconda-postgres` - Anaconda + PostgreSQL

**Example usage**:
```json
{
  "image": "mcr.microsoft.com/devcontainers/python:3.11"
}
```

Or apply via CLI:
```bash
devcontainer templates apply \
  -t ghcr.io/devcontainers/templates/python \
  -a '{"imageVariant": "3.11"}' \
  -w .
```

---

### Template Best Practices

#### 1. Clear Metadata
```json
{
  "name": "Specific, Descriptive Name",
  "description": "Explain what this template provides and who it's for",
  "keywords": ["python", "fastapi", "postgresql"]
}
```

#### 2. Comprehensive Documentation

Include `README.md` in template:
```markdown
# Template Name

### What's Included in Template Starter
- Tool 1
- Tool 2

### Getting Started Creating Templates
1. Step 1
2. Step 2

### Template Configuration Options
- `option1`: Description
- `option2`: Description
```

#### 3. Useful Options

Expose meaningful options:
```json
{
  "options": {
    "nodeVersion": {
      "type": "string",
      "proposals": ["20", "18", "16"],
      "default": "20",
      "description": "Node.js version to install"
    },
    "includeDocker": {
      "type": "boolean",
      "default": false,
      "description": "Include Docker-in-Docker for container builds"
    }
  }
}
```

#### 4. Testing Before Publishing

Test template locally:
```bash
# Apply template
devcontainer templates apply -t ./src/my-template -w ./test-dir

# Open in VS Code
code test-dir

# Test in container
# (Verify all tools work, scripts run, etc.)
```

#### 5. Versioning

Use semantic versioning:
- **Patch** (1.0.1): Bug fixes, documentation
- **Minor** (1.1.0): New options, backward-compatible features
- **Major** (2.0.0): Breaking changes, incompatible updates

Update `devcontainer-template.json`:
```json
{
  "version": "1.2.0"
}
```

#### 6. Security

- Pin dependency versions in Dockerfile/requirements
- Scan images for vulnerabilities
- Don't include secrets or credentials
- Use official base images when possible

---

### Versioning & Updates

Templates use **semantic versioning** independently:

**src/template-a/devcontainer-template.json**:
```json
{
  "id": "template-a",
  "version": "1.2.0"
}
```

**src/template-b/devcontainer-template.json**:
```json
{
  "id": "template-b",
  "version": "2.0.1"
}
```

**Publishing behavior**:
- Publishing tools won't republish if version unchanged
- Must increment version for updates to distribute
- Collection metadata (`devcontainer-collection.json`) tracks all template versions

---

### Advanced: Template Options Conditional Logic

Use template options to conditionally include features:

**devcontainer-template.json**:
```json
{
  "options": {
    "includeDocker": {
      "type": "boolean",
      "default": false
    }
  }
}
```

**devcontainer.json**:
```json
{
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": "${templateOption:includeDocker}"
  }
}
```

If user selects `includeDocker: true`, feature is included. If `false`, it's removed during template application.

---

### Example: Complete Template Workflow

#### 1. Create Template Repository

```bash
git clone https://github.com/devcontainers/template-starter.git myorg-templates
cd myorg-templates
```

#### 2. Create Custom Template

**src/react-typescript-template/devcontainer-template.json**:
```json
{
  "id": "react-typescript-template",
  "version": "1.0.0",
  "name": "React + TypeScript + Tailwind",
  "description": "Complete React development environment with TypeScript, Tailwind CSS, and testing",
  "options": {
    "nodeVersion": {
      "type": "string",
      "proposals": ["20", "18"],
      "default": "20"
    }
  }
}
```

**src/react-typescript-template/.devcontainer/devcontainer.json**:
```json
{
  "name": "React TypeScript Project",
  "image": "mcr.microsoft.com/devcontainers/typescript-node:${templateOption:nodeVersion}",
  "customizations": {
    "vscode": {
      "extensions": [
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "bradlc.vscode-tailwindcss"
      ]
    }
  },
  "forwardPorts": [3000],
  "postCreateCommand": "npm install"
}
```

**src/react-typescript-template/package.json**:
```json
{
  "name": "react-app",
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.0",
    "typescript": "^5.0.0",
    "vite": "^5.0.0",
    "tailwindcss": "^3.3.0"
  }
}
```

#### 3. Test Locally

```bash
devcontainer templates apply \
  -t ./src/react-typescript-template \
  -a '{"nodeVersion": "20"}' \
  -w ./test-project

code test-project
```

#### 4. Publish to GHCR

```bash
# Commit changes
git add src/react-typescript-template
git commit -m "Add React TypeScript template v1.0.0"
git push origin main

# GitHub Actions automatically publishes to ghcr.io/myorg/templates/react-typescript-template:1.0.0
```

#### 5. Team Uses Template

Team members in VS Code:
1. Command Palette → "Add Dev Container Configuration"
2. Select "React + TypeScript + Tailwind"
3. Choose Node version
4. Template applied, ready to code!

---

### Sources
- **Official Templates Specification**: https://containers.dev/implementors/templates-distribution/
- **Template Distribution**: https://containers.dev/implementors/templates/
- **Template Repository**: https://github.com/devcontainers/templates
- **Template Starter**: https://github.com/devcontainers/template-starter
- **CLI Reference**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md
- **Official Template Browser**: https://containers.dev/templates

---

**END OF DRAFT 4 ADDITIONS**

---

### Integration Instructions for Templates

To integrate these sections into `.devcontainer/llms.txt`:

### 1. Update Table of Contents
Add to ToC:
- Official devcontainer.json Property Reference (after Architecture Overview)
- Lifecycle Hooks Explained (after Step-by-Step: Creating)
- Prebuild Images & CI/CD Automation (after Common Stack Examples)
- Creating & Distributing Templates (after Prebuild Images)

### 2. Insert Sections
Insert each section at the locations indicated above.

### 3. Add Additional Sections
Still to be added in subsequent edits:
- VS Code Tips & Tricks
- Devcontainer CLI Reference
- Enhanced MCP content with Docker MCP Toolkit
- Enhanced Security content with Docker ECI
- Citation additions throughout existing sections

### 4. Draft 5 Planning
After integration, re-evaluate for:
- Completeness gaps
- Additional advanced topics
- Citation quality
- User journey coverage

---

---


---


### Method 1: Start from Scratch (Full Control)

#### Step 1: Create Directory Structure

```bash
mkdir -p .devcontainer
cd .devcontainer
```

#### Step 2: Create devcontainer.json

Create `.devcontainer/devcontainer.json`:

```json
{
  "name": "Claude Code - ${localWorkspaceFolderBasename}",
  "build": {
    "dockerfile": "Dockerfile"
  },
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code"
      ],
      "settings": {
        "terminal.integrated.defaultProfile.linux": "bash"
      }
    }
  },
  "remoteUser": "node",
  "mounts": [
    "source=claude-code-config-${devcontainerId},target=/home/node/.claude,type=volume"
  ],
  "containerEnv": {
    "CLAUDE_CONFIG_DIR": "/home/node/.claude"
  },
  "workspaceFolder": "/workspaces/${localWorkspaceFolderBasename}",
  "postStartCommand": "echo 'Container ready!'"
}
```

**Key Configuration Points**:
- `name`: Human-readable name shown in VS Code status bar
- `build.dockerfile`: Path to Dockerfile (relative to devcontainer.json)
- `customizations.vscode.extensions`: VS Code extensions to auto-install
- `remoteUser`: User account inside container (typically "node", "vscode", or "python")
- `mounts`: Persistent volumes for configuration (survives rebuilds)
- `containerEnv`: Environment variables available in container
- `workspaceFolder`: Where your project appears inside the container
- `postStartCommand`: Commands to run after container starts

#### Step 3: Create Dockerfile

Create `.devcontainer/Dockerfile`:

```dockerfile
FROM node:20

# Install essential tools
RUN apt-get update && apt-get install -y --no-install-recommends \
  git \
  curl \
  ca-certificates \
  sudo \
  && apt-get clean && rm -rf /var/lib/apt/lists/*

# Set up locale for UTF-8 support (prevents encoding issues)
RUN sed -i -e 's/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/locale.gen && \
  locale-gen
ENV LANG=en_US.UTF-8 \
  LANGUAGE=en_US:en \
  LC_ALL=en_US.UTF-8

# Create config directory
RUN mkdir -p /home/node/.claude && \
  chown -R node:node /home/node/.claude

# Set working directory
WORKDIR /workspaces

# Switch to node user for tool installation
USER node

# Install Claude Code
RUN npm install -g @anthropic-ai/claude-code@latest

# Configure git to ignore local settings (prevents accidental API key commits)
RUN git config --global core.excludesfile ~/.gitignore_global && \
  echo ".claude/settings.local.json" > /home/node/.gitignore_global
```

**Key Dockerfile Patterns**:
- Start with a stable base image (`node:20`, `python:3.11`, etc.)
- Install system dependencies as `root`
- Set up locale for proper UTF-8 support (critical for AI tools)
- Create directories and set permissions **before** switching users
- Switch to non-root user for tool installation (security best practice)
- Configure git to protect sensitive files

#### Step 4: Open in VS Code

```bash
# From your project directory
cd /path/to/your/project
code .
```

VS Code will detect `.devcontainer/` and prompt: **"Reopen in Container"**

Click it, and VS Code will:
1. Build the Docker image (5-10 minutes first time)
2. Start the container
3. Connect VS Code to the container
4. Install extensions
5. Run post-start commands

**Subsequent opens are instant** (no rebuild unless you change Dockerfile).

#### Step 5: Verify Setup

```bash
# Inside container terminal (VS Code opens this automatically)
claude --version
node --version
git --version
```

### Method 2: Copy Reference Implementation

```bash
# Clone Anthropic's reference
git clone https://github.com/anthropics/claude-code.git
cd claude-code

# Copy to your project
cp -r .devcontainer /path/to/your/project/
cd /path/to/your/project
code .
```

### Method 3: Use This Repository as Template

If you're reading this llms.txt, the `.devcontainer/` directory in this repo is production-ready. Copy it to your project:

```bash
cp -r .devcontainer /path/to/your/project/
# Edit devcontainer.json and Dockerfile for your needs
```

### Method 4: VS Code Command Palette (Guided Setup)

1. Open VS Code in your project: `code /path/to/project`
2. Command Palette (`Cmd+Shift+P` / `Ctrl+Shift+P`)
3. Type: **"Dev Containers: Add Dev Container Configuration Files"**
4. Select a template (Node.js, Python, etc.)
5. Customize generated files
6. Command Palette → **"Dev Containers: Reopen in Container"**

---

## Step-by-Step: Managing Devcontainers

## Lifecycle Hooks Explained

> **AI Assistant Guidance**: Understanding lifecycle hooks is critical for proper devcontainer configuration. Use this execution order diagram when helping users debug initialization issues.

**Official Documentation**: https://containers.dev/implementors/json_reference/#lifecycle-scripts

Development containers execute commands at specific lifecycle stages. Each hook serves a distinct purpose with different access levels and execution contexts.

### Execution Order Diagram

```
┌─────────────────────────────────────────────────────┐
│  LOCAL MACHINE                                      │
│  ┌───────────────────────────────────────────────┐ │
│  │ 1. initializeCommand                          │ │
│  │    • Runs on host/local machine               │ │
│  │    • Before container exists                  │ │
│  │    • Use: Prepare local files, download deps  │ │
│  └───────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────┐
│  CONTAINER (First Start Only)                       │
│  ┌───────────────────────────────────────────────┐ │
│  │ 2. onCreateCommand                            │ │
│  │    • Runs after container creation            │ │
│  │    • No access to user secrets                │ │
│  │    • Use: Install system packages             │ │
│  └───────────────────────────────────────────────┘ │
│                     ↓                               │
│  ┌───────────────────────────────────────────────┐ │
│  │ 3. updateContentCommand                       │ │
│  │    • Runs when workspace content updates      │ │
│  │    • No access to user secrets                │ │
│  │    • Use: Update dependencies (npm install)   │ │
│  └───────────────────────────────────────────────┘ │
│                     ↓                               │
│  ┌───────────────────────────────────────────────┐ │
│  │ 4. postCreateCommand (waitFor default)        │ │
│  │    • Runs after user assignment               │ │
│  │    • HAS access to user secrets/assets        │ │
│  │    • Runs in BACKGROUND by default            │ │
│  │    • Use: Setup that needs credentials        │ │
│  └───────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────┐
│  CONTAINER (Every Start)                            │
│  ┌───────────────────────────────────────────────┐ │
│  │ 5. postStartCommand                           │ │
│  │    • Runs EVERY time container starts         │ │
│  │    • Use: Start services (docker-compose up)  │ │
│  └───────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
                       ↓
┌─────────────────────────────────────────────────────┐
│  CONTAINER (Every Attach)                           │
│  ┌───────────────────────────────────────────────┐ │
│  │ 6. postAttachCommand                          │ │
│  │    • Runs every time tool attaches            │ │
│  │    • Use: Display welcome message             │ │
│  └───────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

### Hook Details

#### 1. initializeCommand
**Location**: Local/host machine
**When**: Before container creation
**Access**: No container access
**Frequency**: Once per devcontainer configuration

**Use cases**:
- Pre-populate `node_modules/` on host before mounting
- Download large files to avoid container bloat
- Generate configuration files
- Validate prerequisites

**Example**:
```json
{
  "initializeCommand": "echo 'Preparing local workspace...' && npm install"
}
```

**Official Docs**: https://github.com/devcontainers/spec/blob/main/docs/specs/devcontainer-reference.md#initializecommand

---

#### 2. onCreateCommand
**Location**: Inside container
**When**: After container creation (first start only)
**Access**: No user secrets or assets
**Frequency**: Once per container

**Use cases**:
- Install system packages (`apt-get install`)
- Clone git repositories
- Set up file permissions
- Initialize database schemas

**Example**:
```json
{
  "onCreateCommand": "apt-get update && apt-get install -y postgresql-client"
}
```

**Official Docs**: https://containers.dev/implementors/json_reference/#image-specific

---

#### 3. updateContentCommand
**Location**: Inside container
**When**: When workspace content updates
**Access**: No user secrets
**Frequency**: On content changes

**Use cases**:
- Update dependencies (`npm install`, `pip install -r requirements.txt`)
- Rebuild assets
- Run database migrations

**Example**:
```json
{
  "updateContentCommand": "npm install && npm run build"
}
```

**Official Docs**: https://containers.dev/implementors/json_reference/#image-specific

---

#### 4. postCreateCommand
**Location**: Inside container
**When**: After container assigned to user (first start)
**Access**: ✅ **Has access to user secrets, assets, and permissions**
**Execution**: Background by default (non-blocking)
**Frequency**: Once per container (after user assignment)

**Use cases**:
- Configure git with user credentials
- Set up SSH keys
- Initialize user-specific tools
- Run setup scripts requiring authentication

**Example**:
```json
{
  "postCreateCommand": "git config --global user.name 'Your Name' && ./setup.sh"
}
```

**Important**: This is the **default waitFor target**. VS Code waits for this to complete before showing "ready" status.

**Official Docs**: https://containers.dev/implementors/json_reference/#image-specific

---

#### 5. postStartCommand
**Location**: Inside container
**When**: **Every time** container starts
**Access**: Full container access
**Frequency**: Every start

**Use cases**:
- Start background services (`docker-compose up -d`)
- Mount network drives
- Refresh certificates
- Display startup messages

**Example**:
```json
{
  "postStartCommand": "docker-compose up -d database redis && echo 'Services started'"
}
```

**Official Docs**: https://containers.dev/implementors/json_reference/#image-specific

---

#### 6. postAttachCommand
**Location**: Inside container
**When**: Every time a tool attaches to container
**Access**: Full container access
**Frequency**: Every attach (e.g., opening VS Code)

**Use cases**:
- Display welcome message
- Check service health
- Log user sessions
- Trigger monitoring

**Example**:
```json
{
  "postAttachCommand": "echo 'Welcome! Container ready at http://localhost:3000'"
}
```

**Official Docs**: https://containers.dev/implementors/json_reference/#image-specific

---

### Command Syntax Options

All lifecycle hooks support three formats:

#### String (Shell Command)
Executed through a shell, supports pipes, redirection, etc.

```json
{
  "postStartCommand": "npm install && npm run build"
}
```

#### Array (Direct Command)
Passed directly to OS without shell interpretation (more secure, no globbing)

```json
{
  "postStartCommand": ["npm", "install"]
}
```

#### Object (Parallel Execution)
Multiple commands executed in parallel

```json
{
  "postStartCommand": {
    "install-deps": "npm install",
    "start-db": "docker-compose up -d database",
    "log-start": "echo 'Container started'"
  }
}
```

**Parallel execution** is useful for independent tasks (database start + npm install).

### Error Handling

**Cascading Failures**: If a lifecycle hook fails, subsequent hooks **will not execute**.

**Example**:
```
onCreateCommand fails ❌
  ↓
updateContentCommand skipped ⏭️
  ↓
postCreateCommand skipped ⏭️
  ↓
postStartCommand skipped ⏭️
```

**Best practices**:
- Test hooks individually
- Use `set -e` in shell scripts to fail fast
- Log output for debugging
- Keep hooks idempotent (safe to run multiple times)

### Access to User Secrets Timeline

```
Hook                      | Has User Secrets?
─────────────────────────────────────────────
initializeCommand         | ❌ (runs on host)
onCreateCommand           | ❌
updateContentCommand      | ❌
postCreateCommand         | ✅ YES
postStartCommand          | ✅ YES
postAttachCommand         | ✅ YES
```

**Why this matters**: Only use `postCreateCommand` and later hooks for operations requiring:
- Git credentials
- SSH keys
- API tokens
- User-specific configuration

### waitFor Property

The `waitFor` property controls which lifecycle command VS Code waits for before considering the container "ready".

```json
{
  "waitFor": "postCreateCommand"  // Default
}
```

**Options**:
- `"initializeCommand"`: Wait before container creation
- `"onCreateCommand"`: Wait after container creation
- `"updateContentCommand"`: Wait after content sync
- `"postCreateCommand"`: **Default** - wait after user assignment
- `"postStartCommand"`: Wait after container start
- `"postAttachCommand"`: Wait after tool attachment

**Use case**: If your `postCreateCommand` is slow (large npm install), users see "ready" status only after it completes.

### Common Patterns

#### Pattern 1: System Setup + Dependency Install
```json
{
  "onCreateCommand": "apt-get update && apt-get install -y build-essential",
  "updateContentCommand": "npm install",
  "postCreateCommand": "npm run setup-user-config"
}
```

#### Pattern 2: Background Services
```json
{
  "postStartCommand": {
    "start-postgres": "docker-compose up -d postgres",
    "start-redis": "docker-compose up -d redis",
    "wait-for-services": "wait-for-it.sh postgres:5432 redis:6379"
  }
}
```

#### Pattern 3: Multi-Language Project
```json
{
  "postCreateCommand": {
    "install-npm": "npm install",
    "install-python": "pip install -r requirements.txt",
    "install-go": "go mod download"
  }
}
```

### Debugging Lifecycle Hooks

**View execution logs**:
```bash
# Inside container
docker logs <container-id>

# Or from VS Code
# View → Output → Select "Dev Containers"
```

**Test individual hook**:
```bash
# Run command manually inside container
docker exec -it <container-id> bash
# Then run the command to test
```

**Common issues**:
- **Hook hangs**: Check for interactive prompts (use `-y` flags, `DEBIAN_FRONTEND=noninteractive`)
- **Hook fails silently**: Add logging (`echo "Step 1..."`)
- **Commands not found**: Check PATH in containerEnv
- **Permission denied**: Verify remoteUser has necessary permissions

### Sources
- **Lifecycle Scripts Reference**: https://containers.dev/implementors/json_reference/#lifecycle-scripts
- **Devcontainer Reference**: https://github.com/devcontainers/spec/blob/main/docs/specs/devcontainer-reference.md#lifecycle-scripts
- **VS Code Lifecycle Docs**: https://code.visualstudio.com/docs/devcontainers/create-dev-container#_lifecycle-scripts
- **Issue Discussion**: https://github.com/devcontainers/spec/issues/477

---


---


### Opening an Existing Devcontainer

**Method 1: Automatic Prompt**
1. Open project in VS Code: `code /path/to/project`
2. Click **"Reopen in Container"** when prompted

**Method 2: Manual Command**
1. Command Palette (`Cmd+Shift+P` / `Ctrl+Shift+P`)
2. Type: **"Dev Containers: Reopen in Container"**

**Method 3: From Remote Window**
1. Click the green icon in bottom-left corner of VS Code
2. Select **"Reopen in Container"**

### Rebuilding After Configuration Changes

When you modify `.devcontainer/devcontainer.json` or `Dockerfile`:

1. Command Palette (`Cmd+Shift+P` / `Ctrl+Shift+P`)
2. Select: **"Dev Containers: Rebuild Container"**
3. Choose:
   - **"Rebuild"**: Preserves volumes (keeps API keys, configs)
   - **"Rebuild Without Cache"**: Fresh build (slower, but resolves caching issues)

**Best Practice**:
- Use **"Rebuild"** for config changes (faster, preserves state)
- Use **"Rebuild Without Cache"** if experiencing mysterious errors

### Accessing the Container Terminal

VS Code automatically opens terminals inside the container. You can also:

**From Host Machine**:
```bash
# Find container ID
docker ps

# Execute command in container
docker exec -it <container-id> bash

# Or by name
docker exec -it <container-name> bash
```

### Viewing Container Logs

```bash
# See build and startup logs
docker logs <container-id>

# Follow logs in real-time
docker logs -f <container-id>
```

### Stopping the Container

**Method 1**: Close VS Code window
**Method 2**: Command Palette → **"Dev Containers: Close Remote Connection"**
**Method 3**: Docker Desktop → Containers → Stop

Container stops automatically when VS Code disconnects.

### Removing the Container

```bash
# List all containers (including stopped)
docker ps -a

# Remove specific container
docker rm <container-id>

# Remove container and volumes (CAUTION: deletes API keys!)
docker rm -v <container-id>

# Or via Docker Desktop: Containers → Delete
```

### Managing Disk Space

Devcontainers accumulate over time:

```bash
# See disk usage breakdown
docker system df

# Remove stopped containers
docker container prune

# Remove unused images
docker image prune -a

# Remove unused volumes (CAUTION: may delete configs)
docker volume prune

# Nuclear option: remove ALL unused Docker resources
docker system prune -a --volumes
```

**⚠️ Warning**: `docker system prune -a --volumes` removes **all** unused Docker resources. If you have other Docker projects, this affects them too.

**Safer Approach**:
```bash
# Remove only resources for this project
docker ps -a | grep "your-project-name"  # Find container ID
docker rm <container-id>
docker volume ls | grep "your-project"    # Find volumes
docker volume rm <volume-name>
```

---

## Multi-AI Configuration

Configure multiple AI assistants (Claude Code, OpenAI Codex, Google Gemini) in one container.

### Installing Multiple CLIs

**Dockerfile additions**:

```dockerfile
# Install Claude Code, Codex, Gemini
USER node
RUN npm install -g \
  @anthropic-ai/claude-code@latest \
  @openai/codex \
  @google/gemini-cli
```

### VS Code Extensions

**devcontainer.json additions**:

```json
{
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code",
        "openai.chatgpt",
        "google.gemini-cli-vscode-ide-companion",
        "google.geminicodeassist",
        "github.copilot",
        "github.copilot-chat"
      ]
    }
  }
}
```

### Persistent Configurations (Critical!)

**Separate volumes for each AI** to prevent credential conflicts:

```json
{
  "mounts": [
    "source=claude-code-config-${devcontainerId},target=/home/node/.claude,type=volume",
    "source=codex-config-${devcontainerId},target=/home/node/.codex,type=volume",
    "source=gemini-config-${devcontainerId},target=/home/node/.gemini,type=volume"
  ]
}
```

**Why separate volumes?**
- Each AI stores API keys in its config directory
- Rebuilding container doesn't lose credentials
- Different projects can have different API keys
- Credential isolation improves security

### Verifying Multi-AI Setup

```bash
# Inside container
claude --version
codex --version
gemini --version

# Check config directories exist
ls -la ~/.claude ~/.codex ~/.gemini
```

### Claude Code Performance Optimization for Devcontainers

> **AI Assistant Guidance**: For devcontainer environments (trusted, isolated), recommend enabling these performance flags to dramatically improve Claude Code's development speed.

**Why optimize for devcontainers?**
- Devcontainers are **isolated** from host system (limited damage potential)
- Network firewall restricts outbound connections (controlled security boundary)
- All tool executions are **auditable** via logs and telemetry
- Environment is **disposable** (can rebuild anytime if issues occur)
- Running as non-root user limits impact
- **Result**: Safe to skip permission prompts for faster development

#### Recommended Settings for Devcontainers

Add to `~/.claude/settings.json` or `.devcontainer/settings.json.template`:

```json
{
  "$schema": "https://json.schemastore.org/claude-code-settings.json",
  "dangerously_skip_permissions": true,
  "verbose": true,
  "env": {
    "MAX_MCP_OUTPUT_TOKENS": "60000",
    "BASH_DEFAULT_TIMEOUT_MS": "300000",
    "BASH_MAX_TIMEOUT_MS": "600000",
    "MAX_THINKING_TOKENS": "8192"
  }
}
```

#### Flag Explanations

**`dangerously_skip_permissions: true`**
- **What**: Skips user confirmation prompts before executing tools (Bash, Read, Write, etc.)
- **Why**: Eliminates delays waiting for permission confirmation
- **Effect**: Claude Code executes tools immediately without prompts
- **Speed Improvement**: 50-80% faster responses (no prompt delays)
- **Safe when**: Running in isolated devcontainer with network restrictions
- ⚠️ **WARNING**: **NEVER** use this flag on host system or with untrusted code!

**`verbose: true`**
- **What**: Enables detailed logging for all operations
- **Why**: Easier debugging of MCP servers, tool failures, and network issues
- **Effect**: More informative error messages and execution traces
- **Performance Impact**: None (logging is async)
- **Safe**: Always safe to enable

**Extended timeouts**:
- `BASH_DEFAULT_TIMEOUT_MS: "300000"` - 5 minutes for Bash commands (default)
- `BASH_MAX_TIMEOUT_MS: "600000"` - 10 minutes maximum timeout
- **Why**: Long-running builds, npm installs, database migrations won't timeout
- **Safe**: No security implications, just prevents premature timeouts

**High token limits**:
- `MAX_MCP_OUTPUT_TOKENS: "60000"` - MCP servers can return more data
- `MAX_THINKING_TOKENS: "8192"` - Claude can think through complex problems longer
- **Why**: Better quality responses, fewer "output truncated" errors
- **Cost**: Slightly higher API usage, but better results

#### Implementation in Devcontainer Templates

**.devcontainer/settings.json.template**:
```json
{
  "$schema": "https://json.schemastore.org/claude-code-settings.json",
  "dangerously_skip_permissions": true,
  "verbose": true,
  "env": {
    "MAX_MCP_OUTPUT_TOKENS": "60000",
    "BASH_DEFAULT_TIMEOUT_MS": "300000",
    "BASH_MAX_TIMEOUT_MS": "600000",
    "MAX_THINKING_TOKENS": "8192"
  },
  "mcpServers": {
    "context7": {
      "transport": {"type": "sse", "url": "https://mcp.context7.com/sse"}
    }
  }
}
```

**Init script to apply settings** (`.devcontainer/init-claude-config.sh`):
```bash
#!/bin/bash
set -euo pipefail

# Create .claude directory if doesn't exist
mkdir -p ~/.claude

# Copy template to settings.json if not exists
if [ ! -f ~/.claude/settings.json ]; then
  cp /usr/local/share/claude-defaults/settings.json ~/.claude/settings.json
  echo "Initialized Claude Code settings with performance flags"
else
  echo "Claude Code settings already exist, skipping..."
fi
```

**devcontainer.json** (run init script on container start):
```json
{
  "postStartCommand": "sudo /usr/local/bin/init-claude-config.sh"
}
```

#### Security Considerations

**Why this is SAFE in devcontainers**:
1. ✅ **Isolated environment** - Container can't access host files directly
2. ✅ **Network firewall** - Outbound connections restricted to whitelisted domains
3. ✅ **Non-root user** - Limited privilege (e.g., `node` user UID 1000)
4. ✅ **Auditable** - All tool executions logged via OpenTelemetry/Prometheus
5. ✅ **Disposable** - Can rebuild container if compromised
6. ✅ **Volume isolation** - Each project gets separate credential volumes

**When NOT to use these flags**:
- ❌ Running on host system (not in container)
- ❌ Untrusted codebases or repositories
- ❌ Production environments
- ❌ Shared machines or CI/CD runners
- ❌ When required to audit every tool execution before running

**Alternative**: If security policies prohibit `dangerously_skip_permissions`, keep `verbose: true` and extended timeouts for improved debugging without skipping prompts.

#### Verification

```bash
# Check settings are applied
cat ~/.claude/settings.json | jq '{dangerously_skip_permissions, verbose}'

# Expected output:
# {
#   "dangerously_skip_permissions": true,
#   "verbose": true
# }

# Test Claude Code responds faster
claude chat
# Try a command that uses tools - notice no permission prompts!
```

#### Performance Impact Summary

| Setting | Speed Improvement | Safety Trade-off | Recommended |
|---------|------------------|------------------|-------------|
| `dangerously_skip_permissions` | 50-80% faster | Low in devcontainer | ✅ Yes (devcontainer only) |
| `verbose` | None (better debugging) | None | ✅ Always |
| Extended timeouts | Prevents failures | None | ✅ Always |
| High token limits | Better responses | Slightly higher cost | ✅ Yes |

**Bottom line**: For devcontainer development, enabling these flags provides **significantly faster** coding experience with **minimal security risk** due to container isolation.

### Sources

- **Claude Code**: https://www.npmjs.com/package/@anthropic-ai/claude-code
- **Claude Code Settings Schema**: https://json.schemastore.org/claude-code-settings.json
- **Devcontainer Security**: https://code.visualstudio.com/docs/devcontainers/containers#_security-and-container-isolation
- **OpenAI Codex**: https://www.npmjs.com/package/@openai/codex
- **Google Gemini CLI**: https://www.npmjs.com/package/@google/gemini-cli
- **GitHub Copilot**: https://github.com/features/copilot
- **VS Code Extension Marketplace**: https://marketplace.visualstudio.com/vscode

---

## MCP Server Setup

Model Context Protocol (MCP) servers extend Claude Code with specialized capabilities.

### What Are MCP Servers?

MCP servers provide Claude Code with access to:
- **External Documentation**: Library docs (Next.js, MongoDB, Cloudflare), API references
- **Tools**: Browser automation (Chromium DevTools), database queries
- **Custom Data**: Company wikis, internal APIs, documentation systems

**Official MCP Documentation**: https://modelcontextprotocol.io

### Transport Types Explained

MCP servers use two transport mechanisms:

**SSE (Server-Sent Events)** - For remote/cloud services
```json
{
  "transport": {
    "type": "sse",
    "url": "https://api.example.com/sse"
  }
}
```
- **Use when**: Server is hosted externally (Context7, Cloudflare Docs)
- **Pros**: No local installation, always up-to-date
- **Cons**: Requires internet, potential rate limits

**stdio (Standard Input/Output)** - For local processes
```json
{
  "command": "npx",
  "args": ["chrome-devtools-mcp@latest"],
  "transport": {
    "type": "stdio"
  }
}
```
- **Use when**: Server runs as local npm package (Chrome DevTools)
- **Pros**: Works offline, full control
- **Cons**: Needs installation, manual updates

### Common MCP Servers

#### Context7 (SSE) - Library Documentation

Provides Claude with access to official documentation for 1000+ libraries.

```bash
# Add via CLI
claude mcp add --transport sse context7 https://mcp.context7.com/sse

# Or in mcp.json
{
  "mcpServers": {
    "context7": {
      "transport": {
        "type": "sse",
        "url": "https://mcp.context7.com/sse"
      }
    }
  }
}
```

**Supported libraries**: Next.js, React, MongoDB, Supabase, Vercel, and more.

#### Cloudflare Docs (SSE) - Cloudflare Product Documentation

```bash
claude mcp add --transport sse cf-docs https://docs.mcp.cloudflare.com/sse

# Or in mcp.json
{
  "mcpServers": {
    "cf-docs": {
      "transport": {
        "type": "sse",
        "url": "https://docs.mcp.cloudflare.com/sse"
      }
    }
  }
}
```

**Covers**: Workers, Pages, R2, D1, KV, Durable Objects, Queues, etc.

#### Chrome DevTools (stdio) - Browser Automation

Requires Chromium installed in Dockerfile.

**Dockerfile additions**:
```dockerfile
RUN apt-get update && apt-get install -y \
  chromium \
  fonts-liberation \
  && apt-get clean && rm -rf /var/lib/apt/lists/*
```

**Add MCP server**:
```bash
claude mcp add --transport stdio chrome-devtools npx chrome-devtools-mcp@latest -- \
  --executablePath=/usr/bin/chromium \
  --headless \
  --chromeArg='--no-sandbox' \
  --chromeArg='--disable-setuid-sandbox' \
  --chromeArg='--disable-dev-shm-usage'
```

**Why these Chrome args?**
- `--no-sandbox`: Required in Docker (containers already sandboxed)
- `--disable-setuid-sandbox`: Docker compatibility
- `--disable-dev-shm-usage`: Prevents /dev/shm memory issues

### Automating MCP Setup

Create `.devcontainer/mcp.json.template`:

```json
{
  "mcpServers": {
    "context7": {
      "transport": {
        "type": "sse",
        "url": "https://mcp.context7.com/sse"
      }
    },
    "cf-docs": {
      "transport": {
        "type": "sse",
        "url": "https://docs.mcp.cloudflare.com/sse"
      }
    }
  }
}
```

Create `.devcontainer/init-claude-config.sh`:

```bash
#!/bin/bash
set -euo pipefail

CLAUDE_HOME="/home/node/.claude"
MCP_FILE="$CLAUDE_HOME/mcp.json"
MCP_TEMPLATE="/usr/local/share/claude-defaults/mcp.json"

echo "Initializing Claude Code configuration..."

# Create .claude directory if it doesn't exist
if [ ! -d "$CLAUDE_HOME" ]; then
    mkdir -p "$CLAUDE_HOME"
    chown node:node "$CLAUDE_HOME"
fi

# Copy MCP configuration if it doesn't exist
if [ ! -f "$MCP_FILE" ]; then
    if [ -f "$MCP_TEMPLATE" ]; then
        cp "$MCP_TEMPLATE" "$MCP_FILE"
        chown node:node "$MCP_FILE"
        echo "✓ MCP servers configured"
    fi
else
    echo "MCP configuration already exists, preserving user settings"
fi
```

**Dockerfile additions**:

```dockerfile
# Copy MCP template to shared location
RUN mkdir -p /usr/local/share/claude-defaults
COPY --chown=node:node mcp.json.template /usr/local/share/claude-defaults/mcp.json

# Copy and configure init script
COPY init-claude-config.sh /usr/local/bin/
USER root
RUN chmod +x /usr/local/bin/init-claude-config.sh && \
  echo "node ALL=(root) NOPASSWD: /usr/local/bin/init-claude-config.sh" > /etc/sudoers.d/node-claude && \
  chmod 0440 /etc/sudoers.d/node-claude
USER node
```

**devcontainer.json additions**:

```json
{
  "postStartCommand": "sudo /usr/local/bin/init-claude-config.sh"
}
```

This ensures MCP servers are automatically configured on first container start, but **preserves user customizations** on subsequent starts.

### Verifying MCP Setup

```bash
# List configured MCP servers
claude mcp list

# Test MCP server (inside Claude Code session)
# Ask Claude: "What's new in Next.js 14?" (uses Context7)
```

### Debugging MCP Issues

```bash
# Check mcp.json exists and is valid JSON
cat ~/.claude/mcp.json | jq

# Test SSE endpoint manually
curl -v https://mcp.context7.com/sse

# Check stdio MCP can run
npx chrome-devtools-mcp@latest --help

# View Claude Code logs
claude --verbose
```

---

### Docker MCP Toolkit Integration


### Docker MCP Toolkit

**What is it**: Docker Desktop integration that simplifies MCP server management with 200+ pre-built, containerized MCP servers.

**Official Announcement**: https://www.docker.com/blog/add-mcp-servers-to-claude-code-with-mcp-toolkit/

#### Features

1. **One-Click Deployment**: Install MCP servers from Docker Desktop UI
2. **200+ Pre-built Servers**: Curated catalog of containerized MCP servers
3. **No Dependency Issues**: Each server runs in isolated container
4. **Automatic Configuration**: Docker Desktop writes to `~/.claude/mcp.json`

#### Using Docker MCP Toolkit

**Step 1: Enable in Docker Desktop**

Docker Desktop → Extensions → Claude Code → Enable

**Step 2: Browse MCP Servers**

Docker Desktop → Claude Code → Browse Servers

**Available categories**:
- Development tools (GitHub, GitLab, Jira)
- Cloud services (AWS, Azure, Google Cloud)
- Databases (PostgreSQL, MongoDB, Redis)
- AI services (OpenAI, Anthropic)
- Custom organization servers

**Step 3: One-Click Install**

Click server → Install → Docker Desktop:
1. Pulls containerized MCP server
2. Starts container
3. Configures `~/.claude/mcp.json` automatically

**Result**: MCP server immediately available in Claude Code.

---

### MCP Proxy for Inter-Container Communication

**Problem**: Claude Code in devcontainer can't use stdio to communicate with MCP servers in other containers.

**Solution**: MCP proxy that bridges stdio and network communication.

**Architecture**:
```
┌─────────────────────────┐
│  Devcontainer           │
│  ┌─────────────────────┐│
│  │ Claude Code         ││
│  │   (OTLP gRPC)       ││
│  └──────────┬──────────┘│
│             │           │
│         stdio → HTTP    │
│             │           │
│  ┌──────────▼──────────┐│
│  │ MCP Proxy           ││
│  └──────────┬──────────┘│
└─────────────┼───────────┘
              │
        HTTP  │
              │
┌─────────────▼───────────┐
│  MCP Server Container   │
│  (GitHub, Database, etc)│
└─────────────────────────┘
```

**Implementation**: Use `@modelcontextprotocol/server-proxy` to bridge connections.

---

### MCP Server Performance Optimization

**Cache frequently accessed data**:

MCP servers can cache responses to reduce latency:

```json
{
  "mcpServers": {
    "context7": {
      "transport": {
        "type": "sse",
        "url": "https://mcp.context7.com/sse"
      },
      "cacheTimeout": 3600
    }
  }
}
```

**Health checks**:

Monitor MCP server availability:

```bash
# Test SSE server
curl -v https://mcp.context7.com/sse

# Test stdio server
npx chrome-devtools-mcp@latest --help
```

---

### Sources
- **Docker MCP Toolkit**: https://www.docker.com/blog/add-mcp-servers-to-claude-code-with-mcp-toolkit/
- **MCP Specification**: https://modelcontextprotocol.io/docs
- **MCP Transports**: https://modelcontextprotocol.io/docs/concepts/transports
- **Server Implementation**: https://modelcontextprotocol.io/docs/concepts/servers

---

## Security Best Practices

### Network Isolation with Firewall

Restrict container network access to only trusted domains, preventing credential exfiltration.

**Create `.devcontainer/init-firewall.sh`**:

```bash
#!/bin/bash
set -euo pipefail

echo "Configuring network firewall..."

# Flush existing rules and create custom chain
iptables -F OUTPUT 2>/dev/null || true
iptables -N ALLOWED_DOMAINS 2>/dev/null || iptables -F ALLOWED_DOMAINS

# Allow localhost (Docker networking, local services)
iptables -A ALLOWED_DOMAINS -d 127.0.0.0/8 -j ACCEPT
iptables -A ALLOWED_DOMAINS -d 172.16.0.0/12 -j ACCEPT
iptables -A ALLOWED_DOMAINS -d 10.0.0.0/8 -j ACCEPT

# Allow DNS (required for domain resolution)
iptables -A ALLOWED_DOMAINS -p udp --dport 53 -j ACCEPT
iptables -A ALLOWED_DOMAINS -p tcp --dport 53 -j ACCEPT

# Allow established connections (responses to our requests)
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Whitelist Anthropic API
iptables -A ALLOWED_DOMAINS -p tcp -d api.anthropic.com --dport 443 -j ACCEPT

# Whitelist npm registry
iptables -A ALLOWED_DOMAINS -p tcp -d registry.npmjs.org --dport 443 -j ACCEPT

# Whitelist GitHub
iptables -A ALLOWED_DOMAINS -p tcp -d github.com --dport 443 -j ACCEPT
iptables -A ALLOWED_DOMAINS -p tcp -d api.github.com --dport 443 -j ACCEPT

# Whitelist MCP servers (Context7, Cloudflare)
iptables -A ALLOWED_DOMAINS -p tcp -d mcp.context7.com --dport 443 -j ACCEPT
iptables -A ALLOWED_DOMAINS -p tcp -d docs.mcp.cloudflare.com --dport 443 -j ACCEPT

# Apply chain to all outbound traffic
iptables -A OUTPUT -j ALLOWED_DOMAINS

# Default deny for anything not explicitly allowed
iptables -P OUTPUT DROP

echo "✓ Firewall configured (only whitelisted domains allowed)"
```

**Dockerfile additions**:

```dockerfile
# Install iptables and ipset for firewall
RUN apt-get update && apt-get install -y \
  iptables \
  ipset \
  && apt-get clean && rm -rf /var/lib/apt/lists/*

# Copy and configure firewall script
COPY init-firewall.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/init-firewall.sh && \
  echo "node ALL=(root) NOPASSWD: /usr/local/bin/init-firewall.sh" > /etc/sudoers.d/node-firewall && \
  chmod 0440 /etc/sudoers.d/node-firewall
```

**devcontainer.json additions**:

```json
{
  "runArgs": [
    "--cap-add=NET_ADMIN",
    "--cap-add=NET_RAW"
  ],
  "postStartCommand": "sudo /usr/local/bin/init-firewall.sh"
}
```

**Testing Firewall**:

```bash
# Inside container
curl https://api.anthropic.com  # Should work
curl https://example.com        # Should fail (not whitelisted)
```

### The `--dangerously-skip-permissions` Flag

**What it does**: Bypasses Claude Code's permission prompts for tool execution.

**When to use**:
- ✅ Trusted devcontainers with firewall enabled
- ✅ Automated CI/CD pipelines
- ✅ Personal projects in isolated containers

**When NOT to use**:
- ❌ Untrusted codebases
- ❌ Open-source projects you haven't audited
- ❌ Production environments
- ❌ Containers without network restrictions

**Official Warning**: "When executed with `--dangerously-skip-permissions`, devcontainers do not prevent a malicious project from exfiltrating anything accessible in the devcontainer including Claude Code credentials."

**Usage**:
```bash
claude --dangerously-skip-permissions
```

### Protecting Sensitive Files

**Always exclude** local settings from git:

```bash
# In Dockerfile
RUN git config --global core.excludesfile ~/.gitignore_global && \
  echo ".claude/settings.local.json" > /home/node/.gitignore_global
```

**Why?** `.claude/settings.local.json` contains API keys. Committing this file exposes credentials.

### Credential Isolation Best Practices

**Use separate devcontainers for**:
- Different clients (prevents client A's credentials leaking to client B)
- Different security levels (public open-source vs. proprietary)
- Different AI services (separate Claude/Codex/Gemini API keys per project)

**How?** Each devcontainer gets isolated volumes (`${devcontainerId}` ensures uniqueness).

### Additional Security Measures

**Read-only bind mounts**:
```json
{
  "mounts": [
    "source=${localEnv:HOME}/.ssh,target=/home/node/.ssh,type=bind,readonly"
  ]
}
```

**Limit container capabilities**:
```json
{
  "runArgs": [
    "--cap-drop=ALL",
    "--cap-add=NET_ADMIN"  // Only if firewall needed
  ]
}
```

**Use minimal base images**:
```dockerfile
FROM node:20-slim  # Instead of node:20 (500MB smaller)
```

---

### Advanced Security Features


### Enhanced Container Isolation (ECI)

**What is ECI**: Docker Desktop feature that prevents malicious containers from compromising the host system using advanced security techniques.

**Official Documentation**: https://docs.docker.com/security/for-admins/hardened-desktop/enhanced-container-isolation/

#### How ECI Works

**Traditional containers**:
- Share host kernel
- Can potentially escalate privileges
- Access Docker socket (if mounted)
- Read host files (if mounted)

**With ECI**:
- **Security boundary between container and Docker Desktop**
- Linux security modules (SELinux, AppArmor) enforced
- Restricted access to Docker socket
- Limited syscalls via seccomp
- Cannot compromise Docker Desktop even if container breached

#### Enabling ECI

**Docker Desktop** → Settings → General → **"Use Enhanced Container Isolation"** → Apply

**Verify ECI active**:
```bash
docker info | grep "Security Options"
# Should show: seccomp, apparmor/selinux, userns
```

---

### User Namespace Remapping

Map container root user to unprivileged host user.

**Problem**: Container root (UID 0) = host root (UID 0) → security risk.

**Solution**: User namespaces remap container UID 0 to host UID 100000+ (non-privileged).

**Enable user namespaces**:

**/etc/docker/daemon.json**:
```json
{
  "userns-remap": "default"
}
```

**Restart Docker**:
```bash
sudo systemctl restart docker
```

**Verify**:
```bash
docker run --rm alpine id
# Shows: uid=0(root) gid=0(root) (inside container)

# On host, process runs as:
ps aux | grep alpine
# Shows: 100000 (unprivileged user)
```

**Official Docs**: https://docs.docker.com/engine/security/userns-remap/

---

### Network Segmentation

Isolate containers by security level using custom networks.

**Create security zones**:
```bash
# DMZ network (public-facing services)
docker network create --driver bridge dmz-network

# Internal network (databases, private services)
docker network create --driver bridge --internal internal-network

# Admin network (management tools)
docker network create --driver bridge admin-network
```

**docker-compose.yml with segmentation**:
```yaml
services:
  frontend:
    image: myapp-frontend
    networks:
      - dmz-network

  backend:
    image: myapp-backend
    networks:
      - dmz-network
      - internal-network

  database:
    image: postgres:15
    networks:
      - internal-network  # Not accessible from DMZ

networks:
  dmz-network:
    external: true
  internal-network:
    external: true
    internal: true  # No external access
```

**Official Docs**: https://docs.docker.com/network/drivers/bridge/#use-user-defined-bridge-networks

---

### Runtime Security Tools

#### gVisor (Application Kernel)

**What**: Sandboxes containers with application kernel for enhanced isolation.

**Install**:
```bash
# Install gVisor
wget https://storage.googleapis.com/gvisor/releases/release/latest/x86_64/runsc
chmod +x runsc
sudo mv runsc /usr/local/bin/

# Configure Docker
sudo mkdir -p /etc/docker
cat <<EOF | sudo tee /etc/docker/daemon.json
{
  "runtimes": {
    "runsc": {
      "path": "/usr/local/bin/runsc"
    }
  }
}
EOF

sudo systemctl restart docker
```

**Use with devcontainer**:
```json
{
  "runArgs": ["--runtime=runsc"]
}
```

**Official Docs**: https://gvisor.dev/docs/user_guide/quick_start/docker/

---

#### Falco (Runtime Threat Detection)

**What**: Detects abnormal behavior in running containers.

**Install**:
```bash
# Helm install
helm repo add falcosecurity https://falcosecurity.github.io/charts
helm install falco falcosecurity/falco
```

**Monitor devcontainers**:
Falco alerts on:
- Unexpected network connections
- File access violations
- Privilege escalation attempts
- Suspicious process spawning

**Official Docs**: https://falco.org/docs/

---

### Seccomp and AppArmor Profiles

Restrict syscalls and capabilities.

**Custom seccomp profile** (restrict-syscalls.json):
```json
{
  "defaultAction": "SCMP_ACT_ERRNO",
  "architectures": ["SCMP_ARCH_X86_64"],
  "syscalls": [
    {
      "names": ["read", "write", "open", "close", "stat", "fstat", "lstat"],
      "action": "SCMP_ACT_ALLOW"
    }
  ]
}
```

**Apply to devcontainer**:
```json
{
  "runArgs": [
    "--security-opt=seccomp=./restrict-syscalls.json"
  ]
}
```

**AppArmor profile**:
```bash
# Load custom profile
sudo apparmor_parser -r -W /etc/apparmor.d/docker-devcontainer
```

**Official Docs**:
- Seccomp: https://docs.docker.com/engine/security/seccomp/
- AppArmor: https://docs.docker.com/engine/security/apparmor/

---

### Capability Restrictions

Drop unnecessary Linux capabilities.

**Best practice**: Drop all, add only required.

```json
{
  "runArgs": [
    "--cap-drop=ALL",
    "--cap-add=NET_BIND_SERVICE"  // Only if binding to ports <1024
  ]
}
```

**Common capabilities**:
- `NET_BIND_SERVICE`: Bind to privileged ports (<1024)
- `SYS_PTRACE`: Debugging with gdb/strace
- `SYS_ADMIN`: Mount filesystems (usually not needed)

**Check container capabilities**:
```bash
docker inspect <container-id> | jq '.[0].HostConfig.CapAdd'
docker inspect <container-id> | jq '.[0].HostConfig.CapDrop'
```

**Official Docs**: https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities

---

### Security Scanning in CI/CD

Scan devcontainer images before deployment.

**Trivy** (vulnerability scanner):
```yaml
# .github/workflows/security-scan.yml
- name: Build devcontainer
  run: devcontainer build --workspace-folder . --image-name myapp-dev:test

- name: Scan with Trivy
  uses: aquasecurity/trivy-action@master
  with:
    image-ref: 'myapp-dev:test'
    format: 'sarif'
    output: 'trivy-results.sarif'

- name: Upload results to GitHub Security
  uses: github/codeql-action/upload-sarif@v2
  with:
    sarif_file: 'trivy-results.sarif'
```

**Official Docs**: https://github.com/aquasecurity/trivy

---

### Sources
- **Docker Security Overview**: https://docs.docker.com/engine/security/
- **Enhanced Container Isolation**: https://docs.docker.com/security/for-admins/hardened-desktop/enhanced-container-isolation/
- **User Namespaces**: https://docs.docker.com/engine/security/userns-remap/
- **Seccomp Profiles**: https://docs.docker.com/engine/security/seccomp/
- **AppArmor**: https://docs.docker.com/engine/security/apparmor/
- **gVisor**: https://gvisor.dev/docs/
- **Falco**: https://falco.org/docs/
- **Network Security**: https://docs.docker.com/network/network-tutorial-standalone/

---


---


When encountering devcontainer issues, follow this systematic diagnostic process:

### Step 1: Identify Error Category

```
Where did the error occur?
├─ Building container? → Go to Step 2: Build Failures
├─ Starting container? → Go to Step 3: Startup Failures
├─ Inside container (tool not working)? → Go to Step 4: Runtime Issues
└─ VS Code connection? → Go to Step 5: VS Code Integration Issues
```

### Step 2: Build Failures

**Symptoms**: "docker build failed", "command not found during build"

**Debug Process**:

```bash
# 1. Check Docker is running
docker ps  # Should NOT error

# 2. View full build logs
# Command Palette → "Dev Containers: Rebuild Container" → Watch Output panel

# 3. Test Dockerfile directly (bypass VS Code)
cd .devcontainer
docker build -t test-build .
# This shows exact line where build fails

# 4. Common fixes:
```

**Common build errors**:

| Error Message | Cause | Fix |
|---------------|-------|-----|
| `E: Package 'xyz' has no installation candidate` | Package name wrong or not in repos | Update `apt-get update` or check spelling |
| `npm ERR! code ENOTFOUND` | Network issue | Check internet, try different npm registry |
| `Permission denied` | Running as wrong user | Check `USER node` comes after `RUN npm install` |
| `/bin/sh: 1: xyz: not found` | PATH not set or tool not installed | Verify tool installation in Dockerfile |

### Step 3: Startup Failures

**Symptoms**: Container builds but fails to start, postStartCommand errors

**Debug Process**:

```bash
# 1. View container logs
docker ps -a  # Find container ID (even if stopped)
docker logs <container-id>

# 2. Check postStartCommand (comment it out temporarily)
# In devcontainer.json:
// "postStartCommand": "sudo /usr/local/bin/init-firewall.sh",

# 3. Try starting container manually
docker run -it <image-id> /bin/bash
# Now run postStartCommand manually to see exact error

# 4. Check init scripts have execute permissions
ls -la .devcontainer/*.sh
# Should show: -rwxr-xr-x (x = executable)

# Fix if needed:
chmod +x .devcontainer/*.sh
```

### Step 4: Runtime Issues (Inside Container)

**Symptoms**: Container runs, but "command not found", "permission denied", or tools don't work

**Debug Process**:

```bash
# 1. Verify PATH
echo $PATH
# Should include /usr/local/bin, /home/node/.npm-global/bin, etc.

# 2. Check tool installation
which claude
which node
which python3

# 3. If "command not found":
ls -la /usr/local/bin  # Check if binary exists
npm list -g --depth=0  # List global npm packages

# 4. Test tool directly with full path
/usr/local/bin/claude --version
/home/node/.npm-global/bin/claude --version

# 5. Check environment variables
env | grep -i claude
env | grep -i path

# 6. Fix PATH in devcontainer.json
{
  "containerEnv": {
    "PATH": "/usr/local/bin:/home/node/.npm-global/bin:${containerEnv:PATH}"
  }
}
```

### Step 5: VS Code Integration Issues

**Symptoms**: Extensions don't install, ports don't forward, terminal doesn't open

**Debug Process**:

```bash
# 1. Check VS Code Server installed in container
docker exec <container-id> ls -la /home/node/.vscode-server

# 2. Reinstall VS Code Server
# Command Palette → "Dev Containers: Rebuild Container Without Cache"

# 3. Check extension installation
# View → Extensions → Filter to "Installed"
# Should show extensions from devcontainer.json

# 4. Manually install extension
# Command Palette → "Extensions: Install Extension"

# 5. Check port forwarding
# Ports tab in VS Code (bottom panel)
# Manually forward: Right-click port → "Forward Port"

# 6. Reset VS Code Remote connection
# Delete ~/.vscode-server in container
docker exec <container-id> rm -rf /home/node/.vscode-server
# Restart VS Code
```

### Step 6: Nuclear Options (When All Else Fails)

```bash
# 1. Rebuild without cache
# Command Palette → "Dev Containers: Rebuild Container Without Cache"

# 2. Remove container and volumes
docker ps -a | grep "your-project"
docker rm -f <container-id>
docker volume ls | grep "your-project"
docker volume rm <volume-name>

# 3. Clean Docker entirely
docker system prune -a --volumes  # CAUTION: Removes everything!

# 4. Restart Docker Desktop
# Quit Docker Desktop → Wait 30 seconds → Restart

# 5. Reset Docker Desktop to factory settings
# Docker Desktop → Troublesoot → Reset to factory defaults
```

---

## Volume Persistence Patterns

Volumes ensure configuration persists across container rebuilds.

### Named Volumes (Recommended for Configs)

**Pattern**: `source=<name>-${devcontainerId},target=<path>,type=volume`

```json
{
  "mounts": [
    "source=claude-code-config-${devcontainerId},target=/home/node/.claude,type=volume",
    "source=bashhistory-${devcontainerId},target=/commandhistory,type=volume",
    "source=npm-cache-${devcontainerId},target=/home/node/.npm,type=volume"
  ]
}
```

**Benefits**:
- ✅ Unique per devcontainer instance (`${devcontainerId}` auto-generated)
- ✅ Survives container deletion (until `docker volume rm`)
- ✅ Fast performance (Docker-managed)
- ✅ Easy to inspect: `docker volume ls`, `docker volume inspect <name>`

**Use cases**: API keys, shell history, package caches

### Bind Mounts (Advanced/Special Cases)

**Pattern**: `source=/host/path,target=/container/path,type=bind`

```json
{
  "mounts": [
    "source=${localEnv:HOME}/.ssh,target=/home/node/.ssh,type=bind,readonly",
    "source=${localWorkspaceFolder}/data,target=/data,type=bind"
  ]
}
```

**Benefits**:
- ✅ Direct access to host filesystem
- ✅ Changes reflect immediately on both sides
- ✅ Useful for debugging, shared data

**Cautions**:
- ⚠️ Exposes host filesystem (security risk if container compromised)
- ⚠️ Platform-specific paths (`/Users/` on Mac, `/home/` on Linux, WSL paths on Windows)
- ⚠️ Performance issues on Mac/Windows (Docker Desktop overhead)

**Use cases**: SSH keys (readonly!), large datasets, debugging

### Common Persisted Paths

```json
{
  "mounts": [
    // AI tool configurations (critical!)
    "source=claude-${devcontainerId},target=/home/node/.claude,type=volume",
    "source=codex-${devcontainerId},target=/home/node/.codex,type=volume",
    "source=gemini-${devcontainerId},target=/home/node/.gemini,type=volume",

    // Shell history (quality of life)
    "source=bashhistory-${devcontainerId},target=/commandhistory,type=volume",

    // Package manager caches (speeds up rebuilds)
    "source=npm-cache-${devcontainerId},target=/home/node/.npm,type=volume",
    "source=cargo-${devcontainerId},target=/home/node/.cargo,type=volume",
    "source=pip-cache-${devcontainerId},target=/home/node/.cache/pip,type=volume"
  ]
}
```

### Inspecting and Managing Volumes

```bash
# List all volumes
docker volume ls

# Inspect specific volume (shows mount point, size)
docker volume inspect claude-code-config-<devcontainerId>

# Access volume data (advanced - mounts volume to temporary Alpine container)
docker run --rm -v claude-code-config-<devcontainerId>:/data alpine ls -la /data

# Backup volume to tarball
docker run --rm -v claude-code-config-<devcontainerId>:/data -v $(pwd):/backup alpine tar czf /backup/claude-backup.tar.gz /data

# Restore volume from tarball
docker run --rm -v claude-code-config-<devcontainerId>:/data -v $(pwd):/backup alpine tar xzf /backup/claude-backup.tar.gz -C /

# Remove unused volumes
docker volume prune

# Remove specific volume (CAUTION: deletes all data!)
docker volume rm claude-code-config-<devcontainerId>
```

### Volume vs Bind Mount Decision Matrix

| Use Case | Volume | Bind Mount |
|----------|--------|------------|
| API keys, configs | ✅ | ❌ |
| Shell history | ✅ | ❌ |
| Package caches | ✅ | ❌ |
| SSH keys (readonly) | ❌ | ✅ |
| Large datasets (shared with host) | ❌ | ✅ |
| Source code | ❌ (VS Code mounts this) | ❌ |
| Debugging container issues | ❌ | ✅ |

---

## Platform-Specific Notes

### macOS (Intel and Apple Silicon)

**Docker Desktop Settings**:
- Allocate at least 4GB RAM, 8GB recommended
- Enable VirtioFS for better file sharing performance (Preferences → Experimental Features)

**Apple Silicon (M1/M2/M3) Specifics**:
```dockerfile
# Some packages need platform specification
FROM --platform=linux/amd64 node:20  # Force x86 emulation (slower but compatible)
# OR
FROM node:20  # Native ARM64 (faster, but ensure all tools support ARM)
```

**Common Issues**:
- **Slow file sync**: Use VirtioFS instead of osxfs
- **Chromium crashes**: Install `chromium` instead of `google-chrome` in Dockerfile
- **Python package build failures**: Install build tools: `apt-get install -y build-essential`

### Windows (WSL2 Required)

**Prerequisites**:
1. Windows 10/11 version 21H2 or higher
2. WSL2 enabled: `wsl --install` in PowerShell (Admin)
3. Docker Desktop → Settings → "Use WSL2 based engine" ✅

**File System Best Practices**:
- ✅ **Store projects in WSL2 filesystem** (`/home/user/projects/`, accessed as `\\wsl$\Ubuntu\home\user\`)
- ❌ **Don't store in Windows filesystem** (`C:\Users\...` is slow via Docker)

**Performance**:
```bash
# Clone projects into WSL2 (FAST)
cd ~
git clone https://github.com/your/project.git
code project

# NOT into Windows drive (SLOW)
cd /mnt/c/Users/You/Documents  # Slow Docker access
```

**Common Issues**:
- **"Docker daemon not responding"**: Restart Docker Desktop
- **Slow builds**: Ensure project is in WSL2 filesystem, not `/mnt/c/`
- **Line ending issues**: Configure git in WSL: `git config --global core.autocrlf input`

### Linux (Native Docker)

**Recommended**: Ubuntu 20.04+, Debian 11+, or equivalent

**Installation** (Ubuntu/Debian):
```bash
# Install Docker Engine (not Desktop)
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# Add user to docker group (no sudo needed)
sudo usermod -aG docker $USER
newgrp docker  # Apply without logout

# Verify
docker run hello-world
```

**File Permissions**:
- Linux containers use **same UID/GID** as files
- If user in container is UID 1000, files will be owned by your host user (UID 1000)
- **Fix permissions issues**:
  ```dockerfile
  ARG USER_UID=1000
  ARG USER_GID=1000
  RUN groupmod --gid $USER_GID node && \
      usermod --uid $USER_UID --gid $USER_GID node
  ```

**Common Issues**:
- **Permission denied**: Add user to `docker` group
- **Docker socket errors**: `sudo systemctl start docker`
- **Out of disk space**: `docker system prune -a` (cleans up old images)

### Sources

- **Docker Desktop for Mac**: https://docs.docker.com/desktop/mac/
- **Docker Desktop for Windows**: https://docs.docker.com/desktop/windows/
- **WSL2 Setup Guide**: https://docs.docker.com/desktop/windows/wsl/
- **Docker Engine for Linux**: https://docs.docker.com/engine/install/
- **Apple Silicon Compatibility**: https://docs.docker.com/desktop/mac/apple-silicon/

---

## Resource and Performance Considerations

### Disk Space Requirements

**Typical Usage**:
- Base Node.js devcontainer: ~1GB
- With build tools + Chromium: ~2-3GB
- Python data science stack: ~4-5GB
- **Recommendation**: Keep 20GB free for comfortable development

**Monitoring**:
```bash
# Check Docker disk usage
docker system df

# Detailed breakdown
docker system df -v
```

**Cleanup Strategies**:
```bash
# Remove old containers (keep images/volumes)
docker container prune

# Remove unused images (rebuilds will redownload)
docker image prune -a

# Remove unused volumes (CAUTION: deletes configs if not careful)
docker volume prune

# Weekly maintenance (safe)
docker container prune && docker image prune
```

### Memory Allocation

**Defaults** (Docker Desktop):
- Mac: 2GB (increase to 4-8GB)
- Windows: 2GB (increase to 4-8GB)
- Linux: No limit (uses host RAM)

**Recommendations by Use Case**:
- Simple Node.js/Python dev: 4GB
- Full-stack with databases: 8GB
- Data science (pandas, ML): 8-16GB

**Configure** (Docker Desktop → Preferences → Resources → Memory)

**Monitor**:
```bash
# Real-time container resource usage
docker stats

# Specific container
docker stats <container-id>
```

### CPU Allocation

**Defaults**: Docker Desktop uses available cores

**Limit CPUs** (if needed):
```json
{
  "runArgs": [
    "--cpus=2"
  ]
}
```

### Build Performance Optimization

**Layer Caching**:
```dockerfile
# GOOD: Dependency changes rarely, cache this layer
COPY package.json package-lock.json ./
RUN npm install
COPY . .  # Source code changes frequently

# BAD: Any source change rebuilds npm install
COPY . .
RUN npm install
```

**Multi-stage Builds** (advanced):
```dockerfile
# Build stage
FROM node:20 AS builder
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

# Runtime stage (smaller final image)
FROM node:20-slim
COPY --from=builder /app/dist /app
```

**Parallel Package Installation**:
```dockerfile
# npm: Use npm ci (faster than npm install)
RUN npm ci

# Python: Use uv instead of pip
RUN pip install uv && uv pip install -r requirements.txt
```

### Network Performance

**DNS Issues**:
```json
{
  "runArgs": [
    "--dns=8.8.8.8",
    "--dns=1.1.1.1"
  ]
}
```

### Startup Time Optimization

**Slow postStartCommand?**
```json
{
  // BAD: Runs sequentially
  "postStartCommand": "npm install && pip install -r requirements.txt && rake setup",

  // GOOD: Run in background, non-blocking
  "postStartCommand": "npm install &"
}
```

### Sources

- **Docker Resource Management**: https://docs.docker.com/config/containers/resource_constraints/
- **Docker Desktop Resource Settings**: https://docs.docker.com/desktop/settings/
- **Performance Best Practices**: https://docs.docker.com/develop/dev-best-practices/
- **Build Cache Optimization**: https://docs.docker.com/build/cache/

---

## Step-by-Step Debug Process

## VS Code Tips & Tricks

> **AI Assistant Guidance**: These productivity enhancements make devcontainers more powerful and user-friendly. Recommend these tips when users ask about optimizing their VS Code devcontainer workflow.

**Official Documentation**: https://code.visualstudio.com/docs/devcontainers/tips-and-tricks

### Copilot Instructions in devcontainer.json

Embed AI coding assistant instructions directly in your devcontainer configuration.

**Feature**: `github.copilot.chat.codeGeneration.instructions`

**devcontainer.json**:
```json
{
  "customizations": {
    "vscode": {
      "settings": {
        "github.copilot.chat.codeGeneration.instructions": [
          {
            "text": "Always use TypeScript strict mode"
          },
          {
            "text": "Prefer functional components in React"
          },
          {
            "text": "Use Tailwind CSS for styling, avoid inline styles"
          },
          {
            "text": "Write comprehensive JSDoc comments for all functions"
          }
        ]
      }
    }
  }
}
```

**Benefits**:
- Consistent AI suggestions across team
- Project-specific coding standards
- Onboard new developers automatically
- Version-controlled AI instructions

**Official Docs**: https://code.visualstudio.com/docs/devcontainers/tips-and-tricks#_copilot-instructions

---

### Settings Sync and Dotfiles

Personalize devcontainers while maintaining team standards.

#### Personal Dotfiles Integration

**Configure in VS Code Settings** (applies to all devcontainers):
```json
{
  "dotfiles.repository": "yourusername/dotfiles",
  "dotfiles.targetPath": "~/dotfiles",
  "dotfiles.installCommand": "install.sh"
}
```

**What happens**:
1. Devcontainer starts
2. VS Code clones your dotfiles repository
3. Runs `install.sh` to set up your personalization
4. Your shell configs, aliases, git config applied

**Example dotfiles repo structure**:
```
dotfiles/
├── .bashrc
├── .zshrc
├── .gitconfig
├── .vimrc
└── install.sh
```

**install.sh**:
```bash
#!/bin/bash
ln -sf ~/dotfiles/.bashrc ~/.bashrc
ln -sf ~/dotfiles/.gitconfig ~/.gitconfig
source ~/.bashrc
```

**Official Docs**: https://code.visualstudio.com/docs/devcontainers/containers#_personalizing-with-dotfile-repositories

---

### Default Extensions vs User Extensions

**Default Extensions** (in devcontainer.json):
- Installed automatically for all users
- Version-controlled, team standard
- Example: ESLint, Prettier, language support

**User Extensions** (from Settings Sync):
- Personal choices (themes, keybindings, etc.)
- Not imposed on team
- Example: Vim emulation, custom themes

**Best practice**:
```json
{
  "customizations": {
    "vscode": {
      "extensions": [
        // Team standards (everyone gets these)
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "ms-python.python"
        // Don't include personal preferences like themes
      ]
    }
  }
}
```

---

### Workspace Trust

Control security when opening untrusted repositories.

**Trust Levels**:
- **Trusted**: Full extension capabilities, run tasks
- **Restricted**: Limited execution, read-only mode

**Configure trust**:
```json
{
  "security.workspace.trust.enabled": true,
  "security.workspace.trust.untrustedFiles": "open",
  "security.workspace.trust.startupPrompt": "always"
}
```

**For devcontainers** (considered safer since isolated):
```json
{
  "security.workspace.trust.enabled": false
}
```

**Use case**: Open untrusted open-source projects in devcontainers without fear of malicious scripts accessing host.

**Official Docs**: https://code.visualstudio.com/docs/editor/workspace-trust

---

### Debugging Configurations

Pre-configure debuggers for the team.

**.vscode/launch.json** (included in project, not devcontainer):
```json
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Debug FastAPI",
      "type": "python",
      "request": "launch",
      "module": "uvicorn",
      "args": ["main:app", "--reload", "--port", "8000"],
      "jinja": true
    },
    {
      "name": "Debug Tests",
      "type": "python",
      "request": "launch",
      "module": "pytest",
      "args": ["-v"]
    }
  ]
}
```

**Combine with devcontainer.json**:
```json
{
  "customizations": {
    "vscode": {
      "extensions": ["ms-python.python"],
      "settings": {
        "python.defaultInterpreterPath": "/usr/local/bin/python"
      }
    }
  }
}
```

Team members open project → debugger pre-configured → press F5 → debug works.

---

### Tasks Integration

Automate common workflows.

**.vscode/tasks.json**:
```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Run Tests",
      "type": "shell",
      "command": "npm test",
      "group": {
        "kind": "test",
        "isDefault": true
      },
      "problemMatcher": []
    },
    {
      "label": "Build Production",
      "type": "shell",
      "command": "npm run build",
      "group": {
        "kind": "build",
        "isDefault": true
      }
    },
    {
      "label": "Start Dev Server",
      "type": "shell",
      "command": "npm run dev",
      "isBackground": true,
      "problemMatcher": {
        "pattern": {
          "regexp": "."
        },
        "background": {
          "activeOnStart": true,
          "beginsPattern": ".",
          "endsPattern": "ready"
        }
      }
    }
  ]
}
```

**Access tasks**: `Cmd+Shift+P` → "Tasks: Run Task"

---

### Port Forwarding Management

#### Automatic Port Forwarding

**devcontainer.json**:
```json
{
  "forwardPorts": [3000, 8080],
  "portsAttributes": {
    "3000": {
      "label": "Frontend Dev Server",
      "protocol": "http",
      "onAutoForward": "openBrowser"
    },
    "8080": {
      "label": "Backend API",
      "protocol": "http",
      "onAutoForward": "notify"
    },
    "5432": {
      "label": "PostgreSQL",
      "onAutoForward": "silent",
      "requireLocalPort": true
    }
  }
}
```

**onAutoForward options**:
- `openBrowser`: Opens in browser automatically
- `openPreview`: Opens in VS Code simple browser
- `notify`: Shows notification
- `silent`: Forwards quietly
- `ignore`: Don't forward

---

### Remote Environment Variables

Access devcontainer context in your shell.

**Available variables**:
```bash
# Inside devcontainer
echo $REMOTE_CONTAINERS           # true
echo $REMOTE_CONTAINERS_IPC       # Path to IPC socket
echo $VSCODE_REMOTE_CONTAINERS_SESSION  # Session ID
```

**Use in scripts**:
```bash
if [ -n "$REMOTE_CONTAINERS" ]; then
  echo "Running in devcontainer"
  # Devcontainer-specific setup
else
  echo "Running locally"
  # Local setup
fi
```

---

### Multi-Root Workspaces

Open multiple projects in one devcontainer.

**workspace.code-workspace**:
```json
{
  "folders": [
    {
      "name": "Frontend",
      "path": "./frontend"
    },
    {
      "name": "Backend",
      "path": "./backend"
    },
    {
      "name": "Shared",
      "path": "./shared"
    }
  ],
  "settings": {
    "terminal.integrated.cwd": "${workspaceFolder:Backend}"
  }
}
```

**devcontainer.json**:
```json
{
  "workspaceFolder": "/workspace",
  "workspaceMount": "source=${localWorkspaceFolder},target=/workspace,type=bind"
}
```

Open `workspace.code-workspace` → All folders accessible in sidebar.

---

### Performance: Exclude Files from Sync

Improve file watching performance by excluding large directories.

**devcontainer.json**:
```json
{
  "customizations": {
    "vscode": {
      "settings": {
        "files.watcherExclude": {
          "**/node_modules/**": true,
          "**/.git/objects/**": true,
          "**/.git/subtree-cache/**": true,
          "**/dist/**": true,
          "**/build/**": true,
          "**/__pycache__/**": true,
          "**/.venv/**": true
        },
        "search.exclude": {
          "**/node_modules": true,
          "**/bower_components": true,
          "**/.venv": true,
          "**/dist": true
        }
      }
    }
  }
}
```

**Impact**: Faster file searches, reduced CPU usage, better responsiveness.

---

### Development Container Features Quick Add

Add features on-the-fly without editing devcontainer.json manually.

**Command Palette** → "Dev Containers: Configure Container Features"
- Browse available features
- Select and configure options
- VS Code updates devcontainer.json automatically
- Rebuild to apply

---

### Sources
- **VS Code Devcontainer Tips**: https://code.visualstudio.com/docs/devcontainers/tips-and-tricks
- **Dotfiles Personalization**: https://code.visualstudio.com/docs/devcontainers/containers#_personalizing-with-dotfile-repositories
- **Workspace Trust**: https://code.visualstudio.com/docs/editor/workspace-trust
- **Tasks**: https://code.visualstudio.com/docs/editor/tasks
- **Debugging**: https://code.visualstudio.com/docs/editor/debugging

---

## Remote Development Platforms

> **AI Assistant Guidance**: Dev containers work with multiple platforms beyond local Docker Desktop. This section covers GitHub Codespaces, Gitpod, and other remote development scenarios.

### GitHub Codespaces

**What is it**: Cloud-based VS Code environment that runs your devcontainer in GitHub's infrastructure.

**Benefits**:
- Zero local setup (no Docker Desktop needed)
- Powerful cloud machines (up to 32 cores, 64GB RAM)
- Billed per-hour usage
- Pre-configured for your repository

**How it works**:
1. GitHub reads `.devcontainer/devcontainer.json` from your repo
2. Builds container in cloud
3. Opens browser-based or local VS Code connected to cloud container

**Configuration** (same as local devcontainer):

```json
{
  "name": "My Project",
  "image": "node:20",
  "customizations": {
    "codespaces": {
      "openFiles": ["README.md", "src/index.ts"]
    }
  }
}
```

**Codespaces-specific settings**:

```json
{
  "hostRequirements": {
    "cpus": 4,
    "memory": "8gb",
    "storage": "32gb"
  },
  "customizations": {
    "codespaces": {
      "openFiles": ["README.md"],
      "repositories": {
        "my-org/my-other-repo": {
          "permissions": "read-all"
        }
      }
    }
  }
}
```

**Using Codespaces**:

```bash
# Create codespace from CLI
gh codespace create --repo myorg/myrepo

# Or from GitHub UI
# Repository → Code → Codespaces → New codespace
```

**Prebuild Configuration** (`.github/workflows/codespaces-prebuild.yml`):

```yaml
name: Codespaces Prebuild
on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: devcontainers/ci@v0.3
        with:
          push: always
          refFilterForPushFilter: refs/heads/main
```

**Pricing** (as of 2024):
- Free tier: 120 core-hours/month
- 2-core machine: ~$0.18/hour
- 4-core machine: ~$0.36/hour
- Storage: $0.07/GB-month

**Sources**:
- **Codespaces Docs**: https://docs.github.com/en/codespaces
- **devcontainer.json for Codespaces**: https://docs.github.com/en/codespaces/setting-up-your-project-for-codespaces/adding-a-dev-container-configuration

---

### Gitpod

**What is it**: Cloud development environment similar to Codespaces, works with GitHub/GitLab/Bitbucket.

**Configuration** (`.gitpod.yml`):

```yaml
image:
  file: .devcontainer/Dockerfile

tasks:
  - init: npm install
    command: npm run dev

ports:
  - port: 3000
    onOpen: open-preview

vscode:
  extensions:
    - anthropic.claude-code
    - dbaeumer.vscode-eslint
```

**Using existing devcontainer** (Gitpod can read devcontainer.json):

```yaml
image:
  file: .devcontainer/devcontainer.json
```

**Pricing**:
- Free tier: 50 hours/month
- Standard: $9/month (100 hours)
- Professional: Custom pricing

**Sources**:
- **Gitpod Docs**: https://www.gitpod.io/docs
- **Using devcontainers in Gitpod**: https://www.gitpod.io/docs/configure/dev-containers

---

### Remote SSH Development

**Scenario**: Connect local VS Code to devcontainer running on remote server.

**Setup**:

1. **Install Remote-SSH extension** in VS Code
2. **SSH into remote server**, clone project
3. **Start devcontainer** on remote server:
   ```bash
   devcontainer up --workspace-folder /path/to/project
   ```
4. **Connect VS Code** to remote devcontainer:
   - VS Code → Remote Explorer → SSH Targets
   - Connect to server
   - Open project folder
   - Container will auto-start

**Use cases**:
- Development on powerful remote workstation
- Accessing GPU resources for ML
- Building ARM images on ARM server

**Sources**:
- **Remote SSH**: https://code.visualstudio.com/docs/remote/ssh
- **Developing in WSL**: https://code.visualstudio.com/docs/remote/wsl

---

### JetBrains IDEs (IntelliJ, PyCharm, WebStorm)

**Status**: JetBrains has limited devcontainer support via "Dev Containers" plugin.

**Setup**:

1. Install "Dev Containers" plugin
2. Open project with `.devcontainer/`
3. IDE reads devcontainer.json and starts container

**Limitations**:
- Not all devcontainer.json properties supported
- Primarily works with `image` property
- `customizations.vscode` settings ignored

**Alternative**: Use Remote Development plugin for Docker containers:

```xml
<!-- .idea/workspace.xml -->
<component name="DockerSettings">
  <option name="targetName" value="your-container" />
</component>
```

**Sources**:
- **JetBrains Dev Containers**: https://www.jetbrains.com/help/idea/connect-to-devcontainer.html
- **Docker Plugin**: https://www.jetbrains.com/help/idea/docker.html

---

### Platform Comparison

| Feature | Local (Docker Desktop) | GitHub Codespaces | Gitpod | Remote SSH |
|---------|------------------------|-------------------|---------|------------|
| **Setup Time** | 5-10 min first build | Instant (with prebuild) | Instant (with prebuild) | Varies |
| **Cost** | Free (local resources) | ~$0.18/hour | Free tier: 50h/mo | Server cost |
| **Performance** | Depends on laptop | Up to 32 cores | Up to 16 cores | Server specs |
| **Offline Support** | ✅ Yes | ❌ No | ❌ No | ❌ No |
| **GPU Access** | Limited (macOS) | ❌ No | ❌ No | ✅ Yes (if server has GPU) |
| **Team Collaboration** | Via git only | ✅ Live Share built-in | ✅ Live Share | Via git only |
| **Best For** | Individual dev, offline work | Teams, onboarding, demos | Open source projects | GPU/ML work, powerful servers |

---

### Choosing the Right Platform

**Use Local Docker Desktop if**:
- ✅ You work offline frequently
- ✅ You have a powerful laptop (16GB+ RAM)
- ✅ You need full control over environment
- ✅ You're working solo or small team

**Use GitHub Codespaces if**:
- ✅ Team collaboration is priority
- ✅ You want instant onboarding for new devs
- ✅ You need to demo features to clients
- ✅ You already use GitHub
- ✅ Budget allows ~$50-100/month per developer

**Use Gitpod if**:
- ✅ Open source project with contributors
- ✅ Multi-platform repositories (GitHub + GitLab)
- ✅ Want free tier for occasional use
- ✅ Need quick "Open in Gitpod" button for users

**Use Remote SSH if**:
- ✅ You have dedicated development server
- ✅ Need GPU for ML/AI development
- ✅ Building cross-platform (ARM on x86 server)
- ✅ Corporate environment with remote servers

---

## Devcontainer CLI Reference

> **AI Assistant Guidance**: The Dev Container CLI enables non-VS Code workflows, CI/CD integration, and automation. Recommend CLI for testing, scripting, and GitHub Actions integration.

**Repository**: https://github.com/devcontainers/cli
**Documentation**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md

### What is the Dev Container CLI?

The **Dev Container CLI** (`@devcontainers/cli`) is a reference implementation of the Dev Container specification that enables:

- **CI/CD Integration**: Build and test in devcontainers via GitHub Actions, GitLab CI, etc.
- **Non-VS Code Workflows**: Use devcontainers with other editors or headless
- **Automation**: Script devcontainer operations
- **Testing**: Validate devcontainer configurations
- **Prebuild Creation**: Build and publish devcontainer images

**Not just for VS Code**: While VS Code is the primary consumer, the CLI enables broader adoption.

---

### Installation

#### Global Installation (Recommended)

```bash
npm install -g @devcontainers/cli
```

**Verify**:
```bash
devcontainer --version
```

#### Local Installation (Project-specific)

```bash
npm install --save-dev @devcontainers/cli
```

**Usage**:
```bash
npx devcontainer --help
```

---

### Core Commands

#### `devcontainer build`

Build a development container image.

**Basic usage**:
```bash
devcontainer build --workspace-folder .
```

**Build and tag**:
```bash
devcontainer build \
  --workspace-folder . \
  --image-name myproject-dev:latest
```

**Build and push to registry**:
```bash
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name ghcr.io/myorg/myproject-dev:1.0.0
```

**Options**:
- `--workspace-folder <path>`: Project directory (default: `.`)
- `--image-name <name>`: Tag for built image
- `--push`: Push to registry after building
- `--platform <platforms>`: Build for multiple platforms (e.g., `linux/amd64,linux/arm64`)
- `--no-cache`: Build without using cache

**Official Docs**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md#devcontainer-build

---

#### `devcontainer up`

Create and start a development container.

**Basic usage**:
```bash
devcontainer up --workspace-folder .
```

**Output container ID**:
```bash
CONTAINER_ID=$(devcontainer up --workspace-folder . | jq -r .containerId)
echo $CONTAINER_ID
```

**Options**:
- `--workspace-folder <path>`: Project directory
- `--remove-existing-container`: Remove existing container first
- `--skip-post-create`: Skip postCreateCommand
- `--user-data-folder <path>`: VS Code server data location

**Result**: Container created, started, and ready for connections.

**Official Docs**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md#devcontainer-up

---

#### `devcontainer exec`

Execute a command inside a running devcontainer.

**Basic usage**:
```bash
devcontainer exec --workspace-folder . npm test
```

**Run multiple commands**:
```bash
devcontainer exec --workspace-folder . bash -c "npm install && npm test"
```

**Options**:
- `--workspace-folder <path>`: Project directory
- `--remote-env <key=value>`: Set environment variable

**Use case**: CI/CD testing inside devcontainer.

**Official Docs**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md#devcontainer-exec

---

#### `devcontainer run-user-commands`

Run lifecycle commands (onCreateCommand, postCreateCommand, etc.).

**Basic usage**:
```bash
devcontainer run-user-commands --workspace-folder .
```

**Specific hook**:
```bash
devcontainer run-user-commands \
  --workspace-folder . \
  --command postCreateCommand
```

**Use case**: Manually trigger lifecycle hooks for debugging.

---

#### `devcontainer templates`

Manage devcontainer templates.

**Apply template to project**:
```bash
devcontainer templates apply \
  --template-id ghcr.io/devcontainers/templates/python \
  --template-args '{"imageVariant": "3.11"}' \
  --workspace-folder .
```

**Publish templates**:
```bash
devcontainer templates publish \
  -r ghcr.io \
  -n myorg/templates \
  ./src
```

**Official Docs**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md#devcontainer-templates-apply

---

### CI/CD Integration

#### GitHub Actions Example

**.github/workflows/test-in-devcontainer.yml**:
```yaml
name: Test in Dev Container

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install Dev Container CLI
        run: npm install -g @devcontainers/cli

      - name: Build and start devcontainer
        run: |
          CONTAINER_ID=$(devcontainer up --workspace-folder . | jq -r .containerId)
          echo "CONTAINER_ID=$CONTAINER_ID" >> $GITHUB_ENV

      - name: Run tests inside devcontainer
        run: |
          devcontainer exec --workspace-folder . npm test

      - name: Run linter
        run: |
          devcontainer exec --workspace-folder . npm run lint

      - name: Build application
        run: |
          devcontainer exec --workspace-folder . npm run build
```

**Benefits**:
- Tests run in exact same environment as development
- No CI/CD-specific setup scripts
- Reproducible across local and CI

---

#### GitLab CI Example

**.gitlab-ci.yml**:
```yaml
test:
  image: node:20
  before_script:
    - npm install -g @devcontainers/cli
  script:
    - devcontainer up --workspace-folder .
    - devcontainer exec --workspace-folder . pytest
    - devcontainer exec --workspace-folder . npm run build
```

---

### Advanced: Pre-building for CI Speed

**Problem**: CI rebuilds devcontainer on every run (slow).

**Solution**: Pre-build devcontainer image, use in CI.

**Step 1: Build prebuild** (in separate workflow/manually):
```bash
devcontainer build \
  --workspace-folder . \
  --push true \
  --image-name ghcr.io/myorg/myproject-ci:latest
```

**Step 2: Update devcontainer.json** (use prebuild):
```json
{
  "image": "ghcr.io/myorg/myproject-ci:latest"
}
```

**Step 3: CI uses prebuild** (fast!):
```yaml
- name: Start devcontainer (instant, uses prebuild)
  run: devcontainer up --workspace-folder .
```

**Result**: CI startup time: 30s (pull image) instead of 10 minutes (build from scratch).

---

### Testing Devcontainer Configurations

Validate devcontainer.json before committing.

**Test script** (test-devcontainer.sh):
```bash
#!/bin/bash
set -e

echo "Testing devcontainer configuration..."

# Build devcontainer
devcontainer build --workspace-folder .

# Start devcontainer
CONTAINER_ID=$(devcontainer up --workspace-folder . | jq -r .containerId)
echo "Container ID: $CONTAINER_ID"

# Verify tools installed
devcontainer exec --workspace-folder . node --version
devcontainer exec --workspace-folder . python3 --version
devcontainer exec --workspace-folder . git --version

# Run postCreateCommand
devcontainer run-user-commands --workspace-folder .

# Run tests
devcontainer exec --workspace-folder . npm test

echo "✓ Devcontainer configuration valid"
```

**Run in CI**:
```yaml
- name: Test devcontainer
  run: ./test-devcontainer.sh
```

---

### Non-VS Code Workflows

Use devcontainers with other editors.

**Vim/Neovim**:
```bash
# Start devcontainer
devcontainer up --workspace-folder .

# Attach to container with Neovim
docker exec -it $(docker ps -q --filter "label=devcontainer.local_folder=$PWD") nvim .
```

**JetBrains IDEs**:
- Use Docker integration
- Point to devcontainer configuration
- JetBrains reads `.devcontainer/devcontainer.json`

**Official Docs**: https://www.jetbrains.com/help/idea/connect-to-devcontainer.html

---

### Debugging with CLI

**View detailed output**:
```bash
devcontainer build --workspace-folder . --log-level trace
```

**Inspect container**:
```bash
devcontainer up --workspace-folder .
docker inspect $(docker ps -q --filter "label=devcontainer.local_folder=$PWD")
```

**Check lifecycle hooks executed**:
```bash
devcontainer exec --workspace-folder . cat /workspaces/.devcontainer-build.log
```

---

### Sources
- **Dev Container CLI Repository**: https://github.com/devcontainers/cli
- **CLI Reference Documentation**: https://github.com/devcontainers/cli/blob/main/docs/cli-reference.md
- **CI Integration Guide**: https://github.com/devcontainers/ci
- **NPM Package**: https://www.npmjs.com/package/@devcontainers/cli

---


### "Reopen in Container" Button Doesn't Appear

**Cause**: VS Code didn't detect `.devcontainer/devcontainer.json`

**Fix**:
```bash
# 1. Verify file exists
ls .devcontainer/devcontainer.json

# 2. Check JSON syntax
cat .devcontainer/devcontainer.json | jq
# If error, fix JSON syntax

# 3. Manually trigger
# Command Palette → "Dev Containers: Reopen in Container"

# 4. Check .devcontainer isn't in .gitignore
cat .gitignore | grep devcontainer
# Remove any exclusion of .devcontainer/
```

### Build Fails with "Permission Denied"

**Cause**: File permissions or sudo configuration issue

**Fix**:
```dockerfile
# Ensure proper ownership BEFORE switching to node user
USER root
RUN mkdir -p /home/node/.claude && \
  chown -R node:node /home/node/.claude
USER node

# Check init scripts are executable
COPY init-firewall.sh /usr/local/bin/
RUN chmod +x /usr/local/bin/init-firewall.sh
```

### Claude Code Command Not Found

**Cause**: PATH not configured or installation failed

**Fix**:
```dockerfile
# Install as non-root user
USER node
RUN npm install -g @anthropic-ai/claude-code@latest

# Verify installation
RUN claude --version
```

**In devcontainer.json**:
```json
{
  "containerEnv": {
    "PATH": "/home/node/.npm-global/bin:${containerEnv:PATH}"
  }
}
```

### Container Runs Out of Memory

**Cause**: Default Docker memory limits too low

**Fix**:
- **Mac/Windows**: Docker Desktop → Preferences → Resources → Memory → 8GB
- **Linux**: No limit by default, check host RAM: `free -h`

**Verify**:
```bash
# Inside container
docker stats <container-id>
```

### MCP Servers Not Loading

**Cause**: `mcp.json` not created, permissions issue, or invalid JSON

**Fix**:
```bash
# Inside container, check file exists
ls -la ~/.claude/mcp.json
# Should show: -rw-r--r-- node node

# Validate JSON syntax
cat ~/.claude/mcp.json | jq

# Check init script ran
docker logs <container-id> | grep "MCP"
# Should show: "✓ MCP servers configured"

# Manually test MCP server
curl https://mcp.context7.com/sse  # SSE servers should respond
npx chrome-devtools-mcp@latest --help  # stdio servers should run
```

### Port Forwarding Not Working

**Cause**: Port not listed in `devcontainer.json` or firewall blocking

**Fix**:
```json
{
  "forwardPorts": [3000, 8080, 8888],
  "portsAttributes": {
    "3000": {
      "label": "Dev Server",
      "onAutoForward": "notify"
    }
  }
}
```

**Check in VS Code**:
- Ports tab (bottom panel) should list forwarded ports
- Manually forward: Right-click port → "Forward Port"

### Extensions Not Installing

**Cause**: Network issues, incorrect extension ID, or VS Code Server issue

**Fix**:
```bash
# 1. Verify extension ID correct
# VS Code → Extensions → Gear icon → "Copy Extension ID"

# 2. Test network from container
docker exec <container-id> curl -v https://marketplace.visualstudio.com

# 3. Manually install
# Command Palette → "Extensions: Install Extension"

# 4. Rebuild container
# Command Palette → "Dev Containers: Rebuild Container"
```

### Git "Dubious Ownership" Error

**Cause**: VS Code mounts workspace with host user UID, but container user has different UID

**Fix**:
```bash
# Inside container
git config --global --add safe.directory /workspaces/your-project

# Or in Dockerfile (applies to all projects)
RUN git config --global --add safe.directory '*'
```

---

## Migration Guides

> **AI Assistant Guidance**: These step-by-step guides help users migrate existing projects to devcontainers. Customize based on their specific stack.

### Guide 1: Migrating Node.js Projects to Devcontainers

**Scenario**: Existing Node.js project with local `node_modules/`, `.env`, and team using different Node versions.

**Step 1: Analyze Current Setup**

```bash
# Check what you have
node --version                    # e.g., v18.x
npm --version
ls -la | grep -E "package.json|.env|.nvmrc"
```

**Step 2: Create devcontainer.json**

```bash
mkdir -p .devcontainer
cd .devcontainer
```

**`.devcontainer/devcontainer.json`**:
```json
{
  "name": "${localWorkspaceFolderBasename}",
  "image": "node:20",
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code",
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode"
      ],
      "settings": {
        "editor.formatOnSave": true,
        "editor.defaultFormatter": "esbenp.prettier-vscode"
      }
    }
  },
  "postCreateCommand": "npm install",
  "forwardPorts": [3000, 5000],
  "remoteUser": "node",
  "mounts": [
    "source=node_modules-${devcontainerId},target=${containerWorkspaceFolder}/node_modules,type=volume",
    "source=npm-cache-${devcontainerId},target=/home/node/.npm,type=volume"
  ]
}
```

**Step 3: Migrate Environment Variables**

If you have `.env` file:

```json
{
  "containerEnv": {
    "NODE_ENV": "development",
    "DATABASE_URL": "postgresql://postgres:postgres@localhost:5432/mydb"
  }
}
```

Or keep `.env` and add to `.gitignore`:
```bash
echo ".env" >> .gitignore
```

**Step 4: Test Migration**

```bash
# Commit changes
git add .devcontainer/
git commit -m "Add devcontainer configuration"

# Open in container
code .
# Click "Reopen in Container" when prompted
```

**Step 5: Verify**

Inside container:
```bash
node --version      # Should match devcontainer.json image
npm --version
ls node_modules/    # Should be populated after postCreateCommand
npm run dev         # Test your dev server
```

**Step 6: Clean Up Local Environment (Optional)**

```bash
# On host machine, remove local node_modules to save space
rm -rf node_modules
```

---

### Guide 2: Migrating Python Projects to Devcontainers

**Scenario**: Python project with `requirements.txt` or `pyproject.toml`, virtual environment, different Python versions on team.

**Step 1: Analyze Current Setup**

```bash
python --version                  # e.g., 3.10.x
ls -la | grep -E "requirements.txt|pyproject.toml|.venv|venv"
```

**Step 2: Create devcontainer.json**

**`.devcontainer/devcontainer.json`**:
```json
{
  "name": "${localWorkspaceFolderBasename}",
  "image": "python:3.11-slim",
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code",
        "ms-python.python",
        "ms-python.vscode-pylance",
        "charliermarsh.ruff"
      ],
      "settings": {
        "python.defaultInterpreterPath": "/usr/local/bin/python",
        "python.linting.enabled": true,
        "python.formatting.provider": "black"
      }
    }
  },
  "postCreateCommand": "pip install -r requirements.txt",
  "remoteUser": "vscode",
  "mounts": [
    "source=pip-cache-${devcontainerId},target=/home/vscode/.cache/pip,type=volume"
  ]
}
```

**Step 3: Add Dockerfile (if custom tools needed)**

**`.devcontainer/Dockerfile`**:
```dockerfile
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    build-essential \
    && apt-get clean

# Create non-root user
RUN useradd -m -s /bin/bash vscode
USER vscode

# Install Python tools globally
RUN pip install --user black pylint pytest ipykernel

WORKDIR /workspaces
```

Update devcontainer.json:
```json
{
  "build": {"dockerfile": "Dockerfile"},
  // ... rest of config
}
```

**Step 4: Test Migration**

```bash
git add .devcontainer/
git commit -m "Add Python devcontainer"
code .  # Reopen in Container
```

Inside container:
```bash
python --version
pip list
python -m pytest  # Run tests
```

**Step 5: Clean Up**

```bash
# Remove local virtual environment
rm -rf .venv venv __pycache__
```

---

### Guide 3: Migrating Docker Compose Projects

**Scenario**: Existing `docker-compose.yml` with app + database + Redis.

**Step 1: Review Existing docker-compose.yml**

```yaml
# Existing docker-compose.yml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3000:3000"
    volumes:
      - .:/app
    environment:
      DATABASE_URL: postgresql://postgres:postgres@db:5432/mydb

  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: postgres

  redis:
    image: redis:7
```

**Step 2: Create devcontainer.json**

**`.devcontainer/devcontainer.json`**:
```json
{
  "name": "${localWorkspaceFolderBasename}",
  "dockerComposeFile": "../docker-compose.yml",
  "service": "app",
  "workspaceFolder": "/app",
  "customizations": {
    "vscode": {
      "extensions": [
        "anthropic.claude-code",
        "ms-azuretools.vscode-docker"
      ]
    }
  },
  "forwardPorts": [3000, 5432, 6379],
  "postStartCommand": "docker-compose up -d db redis",
  "remoteUser": "node"
}
```

**Step 3: Update docker-compose.yml for devcontainers**

```yaml
version: '3.8'
services:
  app:
    build:
      context: ..
      dockerfile: .devcontainer/Dockerfile
    volumes:
      - ..:/app:cached
    command: sleep infinity  # Keep container running
    environment:
      DATABASE_URL: postgresql://postgres:postgres@db:5432/mydb
      REDIS_URL: redis://redis:6379

  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: postgres
    volumes:
      - postgres-data:/var/lib/postgresql/data

  redis:
    image: redis:7
    volumes:
      - redis-data:/data

volumes:
  postgres-data:
  redis-data:
```

**Step 4: Create Dockerfile**

**`.devcontainer/Dockerfile`**:
```dockerfile
FROM node:20

RUN apt-get update && apt-get install -y \
    git \
    postgresql-client \
    && apt-get clean

USER node
RUN npm install -g @anthropic-ai/claude-code

WORKDIR /app
```

**Step 5: Test**

```bash
code .  # Reopen in Container
```

Inside container:
```bash
# Verify services
docker-compose ps

# Test database connection
psql $DATABASE_URL -c "SELECT version();"

# Test Redis
redis-cli -h redis ping
```

---

### Guide 4: Team Adoption Strategy

**Scenario**: Migrating a team of 5-10 developers to devcontainers.

**Phase 1: Pilot (Week 1)**

1. **Select 1-2 volunteers** from team
2. **Create devcontainer** for main project
3. **Document issues** encountered
4. **Iterate** on configuration

**Phase 2: Documentation (Week 2)**

1. **Write team-specific README** in `.devcontainer/README.md`:
   ```markdown
   # Dev Container Setup

   ## Prerequisites
   - Docker Desktop 4.25+
   - VS Code 1.85+
   - Dev Containers extension

   ## First Time Setup
   1. Clone repo
   2. Open in VS Code
   3. Click "Reopen in Container"
   4. Wait 5-10 min for first build

   ## Troubleshooting
   [Link to common issues]
   ```

2. **Record screen demo** (5 min) showing:
   - Opening project in container
   - Running dev server
   - Making code changes
   - Rebuilding container

**Phase 3: Gradual Rollout (Week 3-4)**

1. **Present to team** (15 min demo + Q&A)
2. **Offer 1-on-1 setup help**
3. **Create Slack/Teams channel** for questions
4. **Make it optional initially** (local dev still works)

**Phase 4: Optimization (Month 2)**

1. **Create prebuild images** (speeds up first start from 10min → 2min):
   ```bash
   devcontainer build --workspace-folder . \
     --push true \
     --image-name ghcr.io/yourorg/project-dev:latest
   ```

2. **Update devcontainer.json** to use prebuild:
   ```json
   {
     "image": "ghcr.io/yourorg/project-dev:latest"
   }
   ```

**Phase 5: Standardization (Month 3)**

1. **Create org-wide template** repository
2. **Establish best practices** doc
3. **Automate prebuild creation** via GitHub Actions
4. **Make devcontainers required** for new projects

**Success Metrics**:
- ✅ Onboarding time: 2 hours → 20 minutes
- ✅ "Works on my machine" incidents: 80% reduction
- ✅ Team satisfaction: survey after 1 month

---

### Sources

- **Migration Best Practices**: https://code.visualstudio.com/docs/devcontainers/containers#_converting-an-existing-project
- **Docker Compose Integration**: https://containers.dev/guide/docker-compose
- **Team Adoption Guide**: https://code.visualstudio.com/docs/devcontainers/devcontainerjson-reference

---

## Common Mistakes and Gotchas

### 1. Installing Tools as Root, Then Switching to Node User

**Mistake**:
```dockerfile
USER node
RUN apt-get install -y git  # ERROR: Permission denied
```

**Fix**: Install system packages as root, then switch to node:
```dockerfile
USER root
RUN apt-get install -y git
USER node
```

### 2. Not Persisting Volumes for AI Configurations

**Mistake**:
```json
{
  "mounts": []  // No volumes!
}
```

**Result**: API keys lost on every rebuild

**Fix**:
```json
{
  "mounts": [
    "source=claude-${devcontainerId},target=/home/node/.claude,type=volume"
  ]
}
```

### 3. Using `npm install` Instead of `npm ci` in Dockerfile

**Mistake**:
```dockerfile
RUN npm install  # Slower, non-deterministic
```

**Fix**:
```dockerfile
# For Dockerfile builds (deterministic, faster)
RUN npm ci

# For postCreateCommand (flexible, after container starts)
"postCreateCommand": "npm install"
```

### 4. Forgetting UTF-8 Locale Configuration

**Mistake**: Omitting locale setup → AI tools get encoding errors

**Fix**: Always include:
```dockerfile
RUN sed -i -e 's/# en_US.UTF-8 UTF-8/en_US.UTF-8 UTF-8/' /etc/locale.gen && \
  locale-gen
ENV LANG=en_US.UTF-8 \
  LANGUAGE=en_US:en \
  LC_ALL=en_US.UTF-8
```

### 5. Hardcoding Absolute Paths in devcontainer.json

**Mistake**:
```json
{
  "workspaceFolder": "/workspaces/my-project"  // Breaks if project renamed
}
```

**Fix**:
```json
{
  "workspaceFolder": "/workspaces/${localWorkspaceFolderBasename}"  // Dynamic
}
```

### 6. Not Ignoring `.claude/settings.local.json` in Git

**Mistake**: Committing API keys to git

**Fix**: Always configure in Dockerfile:
```dockerfile
RUN git config --global core.excludesfile ~/.gitignore_global && \
  echo ".claude/settings.local.json" > /home/node/.gitignore_global
```

### 7. Using Bind Mounts for Credentials

**Mistake**:
```json
{
  "mounts": [
    "source=${localEnv:HOME}/.claude,target=/home/node/.claude,type=bind"
  ]
}
```

**Problem**: Host credentials leak into container (security risk)

**Fix**: Use named volumes (isolated per container):
```json
{
  "mounts": [
    "source=claude-${devcontainerId},target=/home/node/.claude,type=volume"
  ]
}
```

### 8. Running `docker system prune -a --volumes` Without Thinking

**Mistake**: Deleting ALL volumes (loses all API keys)

**Fix**: Selectively remove:
```bash
docker volume ls | grep "project-name"
docker volume rm <specific-volume>
```

### 9. Not Testing Dockerfile Independently

**Mistake**: Only testing via VS Code (slow iteration)

**Fix**: Test Dockerfile directly:
```bash
cd .devcontainer
docker build -t test .
docker run -it test /bin/bash
```

### 10. Using Windows Paths in WSL2 Devcontainers

**Mistake**:
```bash
# Slow! Project in /mnt/c/Users/...
```

**Fix**: Clone projects into WSL2 filesystem:
```bash
cd ~  # /home/user (fast)
git clone ...
```

---

## Quick Reference

### Essential Commands

```bash
# Open project in devcontainer
code /path/to/project

# Rebuild container
# Command Palette → "Dev Containers: Rebuild Container"

# List running containers
docker ps

# View container logs
docker logs <container-id>

# Execute command in container
docker exec -it <container-id> bash

# Clean up Docker resources
docker system prune  # Safe (removes stopped containers, unused images)
docker system prune -a --volumes  # Nuclear (removes EVERYTHING)
```

### File Checklist

- [ ] `.devcontainer/devcontainer.json` (required)
- [ ] `.devcontainer/Dockerfile` (required)
- [ ] `.devcontainer/init-claude-config.sh` (optional, MCP automation)
- [ ] `.devcontainer/mcp.json.template` (optional, MCP servers)
- [ ] `.devcontainer/settings.json.template` (optional, Claude settings)
- [ ] `.devcontainer/init-firewall.sh` (optional, security)

### Minimal Working Example

**devcontainer.json**:
```json
{
  "name": "Claude Code",
  "build": {"dockerfile": "Dockerfile"},
  "customizations": {
    "vscode": {"extensions": ["anthropic.claude-code"]}
  },
  "remoteUser": "node",
  "mounts": ["source=claude-${devcontainerId},target=/home/node/.claude,type=volume"]
}
```

**Dockerfile**:
```dockerfile
FROM node:20
RUN apt-get update && apt-get install -y git && apt-get clean
USER node
RUN npm install -g @anthropic-ai/claude-code@latest
RUN git config --global core.excludesfile ~/.gitignore_global && \
  echo ".claude/settings.local.json" > /home/node/.gitignore_global
```

### Official Resources

- **Claude Code Devcontainers**: https://docs.claude.com/en/docs/claude-code/devcontainer
- **VS Code Devcontainers**: https://code.visualstudio.com/docs/devcontainers/containers
- **Docker Documentation**: https://docs.docker.com/
- **MCP Protocol**: https://modelcontextprotocol.io
- **Dev Containers Spec**: https://containers.dev/

---

## Multi-Container Patterns (Docker Compose)

For complex setups (app + database + cache), use Docker Compose with devcontainers.

**Official Docker Compose Documentation**: https://docs.docker.com/compose/compose-file/
**Dev Container Compose Spec**: https://containers.dev/implementors/json_reference/#compose-specific

### Example: Next.js + PostgreSQL + Redis

**Create `docker-compose.yml` (in project root)**:

```yaml
version: '3.8'
services:
  app:
    build:
      context: .
      dockerfile: .devcontainer/Dockerfile
    volumes:
      - .:/workspaces/my-app:cached
    command: sleep infinity
    environment:
      DATABASE_URL: postgresql://postgres:postgres@db:5432/myapp
      REDIS_URL: redis://redis:6379
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: myapp
    volumes:
      - postgres-data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis-data:/data

volumes:
  postgres-data:
  redis-data:
```

**Update devcontainer.json**:

```json
{
  "name": "Next.js Full Stack",
  "dockerComposeFile": "../docker-compose.yml",
  "service": "app",
  "workspaceFolder": "/workspaces/my-app",
  "customizations": {
    "vscode": {
      "extensions": ["anthropic.claude-code"]
    }
  },
  "forwardPorts": [3000, 5432, 6379],
  "postStartCommand": "npm install",
  "remoteUser": "node"
}
```

**Key Points**:
- `dockerComposeFile`: Points to docker-compose.yml
- `service`: Which service is the "dev" container (where VS Code connects)
- Services can communicate by service name (`db:5432`, `redis:6379`)
- Separate volumes for databases persist data across restarts

### Testing Multi-Container Setup

```bash
# Start all services
docker-compose up -d

# View logs
docker-compose logs app
docker-compose logs db

# Connect to database from app container
docker-compose exec app psql $DATABASE_URL

# Stop all services
docker-compose down

# Stop and remove volumes (deletes database data!)
docker-compose down -v
```

---

## DevContainer Features

VS Code devcontainers support a powerful "Features" system for installing common tools without modifying the Dockerfile.

### What Are Features?

**Features** are self-contained, reusable units that install tools and configure the environment. Think of them as "npm packages" for devcontainers.

**Official Feature Registry**: https://containers.dev/features
**Features Specification**: https://containers.dev/implementors/features/
**Features Distribution**: https://containers.dev/implementors/features-distribution/

### Common Features

#### Git

```json
{
  "features": {
    "ghcr.io/devcontainers/features/git:1": {
      "version": "latest",
      "ppa": true
    }
  }
}
```

#### Docker-in-Docker

```json
{
  "features": {
    "ghcr.io/devcontainers/features/docker-in-docker:2": {
      "version": "latest",
      "moby": true
    }
  }
}
```

#### Node.js (Additional Versions)

```json
{
  "features": {
    "ghcr.io/devcontainers/features/node:1": {
      "version": "18"
    }
  }
}
```

#### Python

```json
{
  "features": {
    "ghcr.io/devcontainers/features/python:1": {
      "version": "3.11"
    }
  }
}
```

#### AWS CLI

```json
{
  "features": {
    "ghcr.io/devcontainers/features/aws-cli:1": {
      "version": "latest"
    }
  }
}
```

### Example: Multi-Tool Setup

```json
{
  "name": "Full-Stack Dev",
  "image": "mcr.microsoft.com/devcontainers/base:ubuntu",
  "features": {
    "ghcr.io/devcontainers/features/node:1": {"version": "20"},
    "ghcr.io/devcontainers/features/python:1": {"version": "3.11"},
    "ghcr.io/devcontainers/features/docker-in-docker:2": {},
    "ghcr.io/devcontainers/features/kubectl-helm-minikube:1": {},
    "ghcr.io/devcontainers/features/github-cli:1": {}
  }
}
```

### Features vs. Dockerfile

| Aspect | Features | Dockerfile |
|--------|----------|------------|
| **Ease of use** | Simple JSON | Requires Docker knowledge |
| **Reusability** | Shared across projects | Project-specific |
| **Customization** | Limited to feature options | Full control |
| **Build time** | Often cached | Depends on layer caching |
| **Best for** | Common tools | Custom setups |

### When to Use Features

✅ **Use Features when:**
- Installing common tools (Git, Docker, AWS CLI, kubectl)
- Sharing configuration across multiple projects
- Want simpler devcontainer.json without Dockerfile

❌ **Use Dockerfile when:**
- Installing custom/proprietary tools
- Need fine-grained control over installation
- Complex multi-step setup required

### Creating Custom Features

You can create custom features for internal tools:

**Example structure**:
```
my-feature/
├── devcontainer-feature.json
└── install.sh
```

**devcontainer-feature.json**:
```json
{
  "id": "my-custom-tool",
  "version": "1.0.0",
  "name": "My Custom Tool",
  "description": "Installs my custom tool",
  "options": {
    "version": {
      "type": "string",
      "default": "latest"
    }
  }
}
```

**install.sh**:
```bash
#!/bin/bash
set -e

VERSION=${VERSION:-"latest"}
echo "Installing My Custom Tool ${VERSION}..."
# Installation commands here
```

Host in a git repo and reference:
```json
{
  "features": {
    "https://github.com/myorg/devcontainer-features/my-custom-tool": {
      "version": "1.0.0"
    }
  }
}
```

---

## Frequently Asked Questions

### General Questions

**Q: Do I need to rebuild the container every time I change my code?**

No! Your code lives in a volume mount. Only rebuild when:
- Changing `.devcontainer/devcontainer.json`
- Changing `.devcontainer/Dockerfile`
- Adding VS Code extensions
- Installing new system packages

**Q: Can I run devcontainers without VS Code?**

Technically yes (using Dev Container CLI), but VS Code integration is the primary use case. For non-VS Code workflows, consider:
- Docker Compose directly
- GitHub Codespaces
- Docker-based CI/CD

**Q: How much disk space do devcontainers use?**

Typical usage:
- Base container: 500MB-2GB
- Per-project volumes: 50-200MB
- Total for 10 projects: ~5-10GB

Monitor with: `docker system df`

**Q: Can I use devcontainers with GitHub Codespaces?**

Yes! GitHub Codespaces uses the exact same `.devcontainer/` configuration. Your devcontainer works locally and in Codespaces without modification.

**Q: What happens to my data if I delete the container?**

- **Named volumes** (claude-${devcontainerId}): Persist until manually deleted
- **Bind mounts**: Data remains on host
- **Container filesystem**: Deleted with container

Always use volumes for API keys and configs!

**Q: Can I have multiple devcontainers in one project?**

Yes! Create multiple devcontainer.json files:

```
.devcontainer/
├── backend/
│   └── devcontainer.json
├── frontend/
│   └── devcontainer.json
└── devcontainer.json  # Default
```

Open with: Command Palette → "Dev Containers: Open Folder in Container" → Select configuration

### Performance Questions

**Q: Why is my devcontainer slow on Mac/Windows?**

File I/O between host and container has overhead on Mac/Windows (not Linux).

**Solutions**:
- Use named volumes instead of bind mounts for dependencies (`node_modules/`, `.venv/`)
- Enable VirtioFS (Mac: Docker Desktop → Experimental Features)
- Store projects in WSL2 filesystem (Windows)

**Q: How can I speed up container builds?**

```dockerfile
# 1. Order layers by change frequency (least → most)
FROM node:20
RUN apt-get update && apt-get install -y git  # Rarely changes
COPY package*.json ./                         # Changes sometimes
RUN npm install                                # Changes when package*.json changes
COPY . .                                       # Changes often

# 2. Use build cache
# Command Palette → "Dev Containers: Rebuild Container" (NOT "Rebuild Without Cache")

# 3. Minimize layers
RUN apt-get update && apt-get install -y \
  git \
  curl \
  && apt-get clean && rm -rf /var/lib/apt/lists/*  # All in one layer
```

**Q: My container uses too much RAM. How do I limit it?**

```json
{
  "runArgs": [
    "--memory=4g",
    "--memory-swap=4g"
  ]
}
```

### Security Questions

**Q: Is it safe to use --dangerously-skip-permissions?**

**Only in trusted environments**:
- ✅ Your own projects in isolated devcontainers with firewall
- ✅ CI/CD pipelines with restricted network
- ❌ Open-source projects you didn't audit
- ❌ Untrusted codebases

The flag bypasses permission prompts, allowing automated execution. Malicious code could exfiltrate your API keys.

**Q: How do I prevent accidentally committing API keys?**

```dockerfile
# In Dockerfile (automatic protection)
RUN git config --global core.excludesfile ~/.gitignore_global && \
  echo ".claude/settings.local.json" > /home/node/.gitignore_global
```

This ensures `.claude/settings.local.json` (which contains API keys) never gets committed.

**Q: Can containers access my host machine?**

Not by default. Containers are isolated unless you explicitly:
- Bind mount host directories (`type=bind`)
- Forward ports
- Add capabilities (`--cap-add`)

Best practice: Only mount what's needed, preferably read-only.

### Multi-AI Questions

**Q: Can I run Claude Code, Copilot, and Gemini in the same container?**

Yes! Install all tools and configure separate volumes:

```dockerfile
RUN npm install -g \
  @anthropic-ai/claude-code@latest \
  @openai/codex \
  @google/gemini-cli
```

```json
{
  "mounts": [
    "source=claude-${devcontainerId},target=/home/node/.claude,type=volume",
    "source=codex-${devcontainerId},target=/home/node/.codex,type=volume",
    "source=gemini-${devcontainerId},target=/home/node/.gemini,type=volume"
  ]
}
```

Each AI gets isolated API keys and settings.

**Q: How do I switch between AI assistants?**

Each has its own CLI command:
```bash
claude     # Anthropic Claude Code
codex      # OpenAI Codex
gemini     # Google Gemini CLI
```

Or use VS Code extensions (switch via sidebar).

### Troubleshooting Questions

**Q: "Reopen in Container" button disappeared after I clicked it once. How do I get back?**

The green icon in bottom-left corner of VS Code. Click it → "Reopen in Container"

Or: Command Palette → "Dev Containers: Reopen in Container"

**Q: How do I access my container if VS Code won't connect?**

```bash
# Find container ID
docker ps

# Execute bash inside
docker exec -it <container-id> bash

# Now you can debug from inside
claude --version
ls -la ~/.claude
cat ~/.claude/mcp.json | jq
```

**Q: My Dockerfile builds locally but fails in VS Code. Why?**

VS Code builds from the project root, not `.devcontainer/` directory.

**Fix paths in Dockerfile**:
```dockerfile
# If devcontainer.json has "dockerfile": "Dockerfile"
# Then COPY paths are relative to .devcontainer/

# Good
COPY init-firewall.sh /usr/local/bin/

# Bad
COPY .devcontainer/init-firewall.sh /usr/local/bin/
```

**Q: How do I completely reset a devcontainer?**

```bash
# 1. Remove container
docker ps -a | grep "project-name"
docker rm -f <container-id>

# 2. Remove volumes (CAUTION: Deletes API keys!)
docker volume ls | grep "project-name"
docker volume rm <volume-name>

# 3. Rebuild
# Command Palette → "Dev Containers: Rebuild Container Without Cache"
```

### MCP Questions

**Q: What's the difference between SSE and stdio MCP servers?**

**SSE (Server-Sent Events)**:
- Remote servers (hosted externally)
- Examples: Context7, Cloudflare Docs
- Requires internet
- No local installation

**stdio (Standard Input/Output)**:
- Local processes (npm packages)
- Examples: Chrome DevTools
- Works offline
- Requires npm installation

**Q: Can I use MCP servers without Claude Code?**

MCP is specific to Claude Code. Other AI assistants have their own extension systems:
- Copilot: GitHub Copilot API
- Cursor: Cursor Rules
- Codex: OpenAI Plugins

**Q: My MCP server shows "not responding". What should I check?**

```bash
# For SSE servers
curl -v https://mcp.context7.com/sse  # Should respond

# For stdio servers
npx chrome-devtools-mcp@latest --help  # Should run

# Check mcp.json syntax
cat ~/.claude/mcp.json | jq  # Should parse without errors

# View Claude logs
claude --verbose
```

---

## Glossary

**API Keys**: Secret tokens for authenticating with AI services (Anthropic, OpenAI, Google).

**Bind Mount**: Direct mapping of host directory to container directory. Changes on either side reflect immediately.

**Container**: Isolated environment running on Docker Engine. Contains OS, tools, and your project.

**Container ID**: Unique identifier for a running container (e.g., `a1b2c3d4e5f6`).

**Dev Container Extension**: VS Code extension (`ms-vscode-remote.remote-containers`) enabling devcontainer support.

**DevContainer Features**: Pre-packaged installations for common tools (Git, Docker, AWS CLI, etc.).

**Docker Compose**: Tool for defining multi-container setups (app + database + cache).

**Docker Desktop**: Docker runtime for Mac/Windows with GUI. Linux uses Docker Engine directly.

**Docker Engine**: The underlying runtime that executes containers.

**Docker Image**: Blueprint for creating containers. Built from Dockerfile.

**Dockerfile**: Text file with instructions for building a Docker image.

**devcontainer.json**: Configuration file telling VS Code how to create and connect to containers.

**Environment Variable**: Key-value pair available to processes in the container (e.g., `CLAUDE_CONFIG_DIR=/home/node/.claude`).

**Extension**: VS Code add-on providing additional functionality (e.g., Claude Code extension).

**Firewall**: Network security rules restricting container's outbound connections.

**Forward Port**: Make container port accessible on host (e.g., container port 3000 → localhost:3000).

**Git-Delta**: Enhanced diff viewer with syntax highlighting (optional tool).

**Host**: Your physical/virtual machine (Mac, Windows, Linux) running Docker.

**Image Layer**: Cached build step in Dockerfile. Speeds up rebuilds.

**iptables**: Linux firewall configuration tool.

**MCP (Model Context Protocol)**: Standard for extending Claude Code with external data/tools.

**Mount**: Connection between host and container filesystem (volume or bind mount).

**Named Volume**: Docker-managed storage that persists across container rebuilds.

**npm Global**: npm packages installed system-wide (with `-g` flag).

**Oh My Zsh**: Popular ZSH configuration framework with themes and plugins.

**OTel (OpenTelemetry)**: Observability framework for metrics, logs, and traces (optional, advanced).

**postStartCommand**: Command executed after container starts (in devcontainer.json).

**Remote User**: User account inside container that VS Code uses (typically `node` or `vscode`).

**runArgs**: Docker CLI arguments passed when starting container (in devcontainer.json).

**SSE (Server-Sent Events)**: HTTP-based protocol for server→client streaming. Used by remote MCP servers.

**stdio (Standard Input/Output)**: Process communication method. Used by local MCP servers.

**Volume**: Persistent storage managed by Docker. Survives container deletion.

**VS Code Server**: Background service VS Code installs in container for remote connection.

**Workspace Folder**: Directory inside container where your project code appears (`/workspaces/your-project`).

**WSL2 (Windows Subsystem for Linux 2)**: Linux kernel running on Windows. Required for Docker Desktop on Windows.

**ZSH (Z Shell)**: Advanced shell with better autocomplete and themes than Bash.

---

## AI Assistant Guidelines

> **For AI Assistants**: When helping users create or debug devcontainers:

### Decision-Making Framework

1. **Assess User Experience**:
   - Beginner? → Start with minimal example, explain each line
   - Intermediate? → Provide working example with customization options
   - Advanced? → Discuss trade-offs, security implications

2. **Understand Requirements**:
   - What's the primary language? → Choose base image
   - Need databases? → Suggest Docker Compose pattern
   - Security concerns? → Recommend firewall, volume isolation
   - Team environment? → Emphasize reproducibility

3. **Provide Progressive Solutions**:
   - **First**: Minimal working setup (get them running)
   - **Then**: Add features (MCP servers, multi-AI, security)
   - **Finally**: Optimize (caching, performance, cleanup)

4. **Always Include**:
   - ✅ UTF-8 locale configuration
   - ✅ Volume mounts for `.claude/` (and other AI configs)
   - ✅ Git exclusion of `.claude/settings.local.json`
   - ✅ Explanation of "why" not just "how"

5. **Test Incrementally**:
   - Suggest testing Dockerfile with `docker build -t test .`
   - Recommend building → testing → adding features → rebuilding
   - Don't give 500-line config without incremental validation

6. **Reference Official Docs**:
   - Link to https://docs.claude.com/en/docs/claude-code/devcontainer
   - Cite VS Code devcontainers docs for advanced features
   - Point to official MCP docs for server configuration

7. **Explain Trade-offs**:
   - Security vs. convenience (firewall vs. open network)
   - Performance vs. disk space (slim images vs. feature-rich)
   - Simplicity vs. robustness (minimal config vs. production-ready)

### Common User Questions (Suggested Responses)

**"How do I add Python to my Node devcontainer?"**
```dockerfile
# In Dockerfile after base image
RUN apt-get update && apt-get install -y \
  python3 \
  python3-pip \
  python3-venv \
  && apt-get clean && rm -rf /var/lib/apt/lists/*
```

**"Can I use my existing Dockerfile?"**
Yes, but recommend separation:
- Production: `Dockerfile` (optimized for size, security)
- Development: `.devcontainer/Dockerfile` (includes dev tools, AI assistants)

**"How do I share my devcontainer with my team?"**
Commit `.devcontainer/` to git. Team members:
1. Pull repo
2. Open in VS Code
3. Click "Reopen in Container"

**"Will this work on Windows?"**
Yes, if using WSL2:
- Docker Desktop → Settings → "Use WSL2 based engine" ✅
- Clone projects into WSL2 filesystem (not `/mnt/c/`), for performance

**"How do I debug build failures?"**
1. Test Dockerfile directly: `docker build -t test .devcontainer/`
2. View full error output (not truncated VS Code log)
3. Use `RUN echo "Checkpoint 1"` to isolate failing line
4. Check [Step-by-Step Debug Process](#step-by-step-debug-process)

**"Should I use devcontainers for [X]?"**
- ✅ Multi-developer teams
- ✅ Projects with complex dependencies
- ✅ Security-sensitive work (client projects)
- ✅ Cross-platform development
- ❌ Simple scripts (overkill)
- ❌ GPU-intensive ML (complex setup)
- ❌ GUI desktop apps

---

**Document Version**: 2.0
**Last Updated**: 2025-10
**Maintained By**: Community
**License**: MIT
**Feedback**: https://github.com/anthropics/claude-code/discussions

---

> **For AI Assistants**: You've reached the end of this comprehensive guide. Remember:
> - **Understand before implementing** - Ask clarifying questions
> - **Start simple, iterate** - Don't overwhelm with 500-line configs
> - **Explain trade-offs** - Security, performance, complexity
> - **Test incrementally** - Build → Test → Add feature → Rebuild
> - **Reference official docs** - https://docs.claude.com/en/docs/claude-code/devcontainer
> - **Prioritize user success** - Working devcontainer > perfect devcontainer

**Your goal**: Help users achieve a **working devcontainer** that solves their problem, not to showcase every advanced feature.
